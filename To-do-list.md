# for Language Standard v0.2

# MiniC89 Language Standard (v0.2) — To-Do List

본 문서는 사용자가 제공한 MiniC89 표준 초안(v0.2)에서 확인된 **수정/보완/결정 필요 항목(To-Do)** 을 정리한 목록이다.  
(표준 문서 정합성 + 구현체 구현 관점 포함)

---

## 0. 최우선 To-Do (정합성/모순 해결)

- [o] **(중대) “MiniC89 ⊂ C89” 성질을 깨는 키워드 정의 수정**
  - 현재 3.2 Keywords가 `int/if/else/for/return/break/continue`만 예약어로 지정되어 있음
  - 결과적으로 `int while;`, `int float;` 같은 코드가 MiniC89에서 식별자로 통과할 수 있음 → C89에서는 불가(키워드)
  - **To-Do:** “ISO C89 키워드 전체를 MiniC89에서도 예약어로 취급” 또는 “식별자는 ISO C89 키워드를 사용할 수 없음”을 규범으로 추가

- [o] **(중대) 4.2/9장 문법 정의 누락 및 참조 불일치 해결**
  - 4.2에서 `<function-definition>`의 규범 정의가 **9.1절**에 있다고 하나, 실제로 9.1이 없고 `<function-definition>` EBNF 자체가 없음
  - **To-Do:** 9장에 `<function-definition>`의 정식 EBNF 추가 + 4.2의 절 번호 참조 일치

- [o] **(중대) MC89-E306 MUST/SHOULD 모순 해결**
  - 8장/5.4.2에서는 `return;`을 **MUST error (E306)**로 요구
  - 11.x.2에서는 E306을 “SHOULD 수준, 생략 가능”이라고 서술 → 충돌
  - **To-Do:** E306을 MUST로 고정하거나, 관련 절을 SHOULD로 낮추는 등 문서 전체 일관화

- [o] **(중대) 4.2 EBNF 블록의 편집 흔적 제거**
  - `BEGIN REPLACEMENT`, 중첩된 ```ebnf 코드펜스 등 편집 잔재가 남아 있음
  - **To-Do:** 최종 표준 형식으로 정리(단일 EBNF 블록 유지, 마커 제거)

---

## 1. 문법(EBNF) 보완/수정 To-Do

- [o] **`<function-definition>` EBNF 명시**
  - 최소 구성:
    - 반환 타입: `int`
    - 함수 이름: `<identifier>`
    - 매개변수 목록: (없을 수도 있음)
    - 본문: `<compound-statement>`
  - `main`은 반드시 `int main()` 형태(매개변수 없음) 제약 포함

- [B] **함수 호출 문법의 “연쇄 호출” 허용 여부 결정**
  - 현재 문법:
    - `<postfix-expression> ::= <primary-expression> { <call-suffix> }`
    - 문법상 `f()()` 같은 형태가 가능해짐
  - **To-Do 옵션 A:** 호출 대상은 `<identifier>`로 제한하여 연쇄 호출을 문법적으로 차단  
  - **To-Do 옵션 B:** 문법은 유지하되 “비함수 값 호출”에 대한 정적 오류 코드 신설/지정

- [o] **파일 스코프 금지(전역 변수/프로토타입) 문법/진단 연결 강화**
  - 4.2/4.3/11.y에 흩어져 있음
  - **To-Do:** 파서 단계에서 “프로토타입 vs 함수 정의” 판별을 어떻게 할지 규범 문장 및 E404/E405 연결을 명확화

- [o] **C89 키워드지만 MiniC89에서 제거된 구문을 ‘식별자’로 토큰화하지 않도록 정리**
  - (0번 키워드 문제 해결과 함께)
  - `while`, `switch`, `struct`, `sizeof` 등은 키워드로 인식되되 문법에 없어서 에러가 나도록 정리

---

## 2. 의미론(semantics) 명확화 To-Do

- [o] **정수 나눗셈/나머지의 음수 처리 규칙 명시**
  - 5.2에서 “결정적으로 제공 SHOULD” 수준이라 채점 안정성이 떨어질 수 있음
  - **To-Do:** `a / b`, `a % b`의 음수 처리(절단 방향, 나머지 부호)를 규범(Normative)으로 고정

- [o] **비교/논리 연산자의 결과 값(0/1) 규정**
  - `!E`는 0/1 규칙이 있으나,
  - `<,<=,>,>=,==,!=,&&,||` 결과가 0/1인지 명확히 규정 필요
  - **To-Do:** “해당 연산의 결과는 0 또는 1”을 규범으로 추가

- [o] **함수 끝 도달(반환문 없음) 정책 결정**
  - 모든 함수 반환 타입이 `int`인데, 함수 끝까지 가면 무엇인지 미정
  - **To-Do:** (권장) 컴파일 타임 오류로 금지(새 오류 코드 필요 가능) 또는 UB로 분류(교육 목적상 비권장)

- [o] **스코프/이름 규칙 명시**
  - 중복 선언 허용 여부
  - shadowing 허용 여부
  - 매개변수와 지역변수 이름 충돌 허용 여부
  - **To-Do:** 정책을 규범으로 추가 + (가능하면) 진단 코드 지정

---

## 3. Diagnostics(진단) 규정 정리 To-Do

- [o] **E208(평가 순서 의존) 판정 규칙 보강**
  - 현재 조건은 있으나 구현자에게 애매한 케이스가 존재(중첩 대입/함수 호출/단락 평가 결합 등)
  - **To-Do:** full-expression 범위 정의 강화 및 예외(단락 평가로 실제 평가되지 않는 부분) 처리 정책 명시

- [o] **E202(definitely initialized) 분석 최소 요구사항 보강**
  - “definitely initialized 분석 MUST”는 강한 요구
  - **To-Do:** 최소 알고리즘/보수적 허용(거짓 양성 허용 여부) 등 규범화

- [o] **`//` 라인 주석 진단 정책 확정**
  - 현재는 “특별 취급하지 않음 + E203 진단 MAY” 수준
  - **To-Do:** `//` 등장 시 MUST error로 할지, 단순 파싱 에러(E205)로 흘릴지, 전용 코드 신설할지 결정

- [o] **전처리 `#...` 진단 코드 정책 확정**
  - `#`는 E101로 처리 가능하나, “전처리 라인 금지” 규정과 구현 연결이 모호
  - **To-Do:** `#` 등장 시 어떤 코드로 진단하는지 규범으로 고정(E101 또는 별도 코드)

- [o] **오탈자/포맷 수정**
  - 예: “생략 가능하다다.” 같은 오탈자
  - 11.y E407 부근 문장/헤더 붙어 깨진 부분
  - **To-Do:** 표준 문서 출력 품질 정리(채점기/IDE 연동 신뢰도 향상)

---
## 4. 문서 완성도 향상 To-Do

- [ ] 표준 전체 목차/절 번호 정리(현재 일부 절 참조 어긋남)
- [ ] “implementation-defined behavior”가 존재하는 경우 목록화 및 “문서화 MUST” 항목 정리
- [ ] Annex에 “추가 테스트 케이스 묶음” 제공(각 오류 코드당 최소 1개)

- [ ] Chapter/Section 번호가 실제 문서 구조와 일치하는지 점검
  - 예: “9.1절” 참조처럼 **존재하지 않는 절 번호**가 남아있지 않도록 정리
- [ ] 헤딩 레벨(`#`, `##`, `###`, `####`) 사용 규칙 고정
  - 예: Chapter는 `##`, 절은 `###`, 하위 항목은 `####`로 통일

- [ ] 모든 코드 블록은 “언어 태그”를 일관되게 사용
  - 예: EBNF는 ```ebnf, C 예제는 ```c
- [ ] 코드 블록 안에는 “규범 문장(MUST/SHOULD)”을 섞지 않기
  - 규범 문장은 코드 블록 밖 `Normative Rules` 섹션에 두기

- [ ] 모든 규범 섹션에 `#### Normative Rules` / `#### Notes (Non-Normative)` 같은 고정 템플릿 적용
- [ ] “Allowed Examples / Forbidden Examples” 제목의 표기 방식 통일
- [ ] “MUST/SHOULD”는 반드시 **대문자일 때만 규범**이라는 원칙을 문서 전체에 적용(소문자 must/should 혼재 제거)

- [ ] 표 구문이 깨지지 않도록 파이프(`|`) 정렬 및 헤더/구분선 확인
- [ ] 긴 표(예: 5.4.2 매핑 표, 11.x.3 매핑 표)는 줄바꿈/폭이 깨질 수 있으므로:
  - (권장) 마크다운 표 대신 “고정폭 코드블록 표”로 바꾸는 것도 검토

- [ ] 대표적으로 다음 패턴을 전역 검색해 수정
  - `..` (점 2개)
  - `다다`
  - `MUST 한다.####` (문장과 헤더 붙음)
  - `MUST 한다.-` (문장 끝에 불필요한 대시)
  - `있다.`/`이다.` 반복으로 생기는 어색한 중복 표현
---


## 구현체(컴파일러/VM/채점기) 구현 To-Do 체크리스트

### 1 Lexer / Tokenizer

- [ ] ASCII 소스 문자 집합 검사(3.6.1) + 위반 시 **MC89-E101**
- [ ] `/* ... */` 주석 처리 + 미종료 시 **MC89-E104**
- [ ] `//` 처리 정책 반영(금지)
- [ ] maximal munch 적용(3.6.3): `==`, `!=`, `<=`, `>=`, `&&`, `||` 우선
- [ ] 10진 정수 리터럴 규칙:
  - 선행 0 금지, hex 금지, digits+letters 금지, 값 범위 0..127
  - 위반 시 **MC89-E103**
- [ ] 키워드/식별자 분류 + (결정된 경우) **C89 키워드 전체 예약 정책 반영**

### 2 Parser

- [ ] translation unit에서 **함수 정의만 허용**(4.2)
  - 전역 변수/전역 선언 → **MC89-E405**
  - 프로토타입(선언만) → **MC89-E404**
- [ ] `int main()` 존재 강제 → **MC89-E401 / MC89-E402**
- [ ] 블록에서 선언이 문장보다 앞에만 오도록 강제 → **MC89-E301**
- [ ] `for`에서 C99 스타일 선언 금지 → **MC89-E302**
- [ ] 표현식 문법(7장) 구현 + 금지 연산자 검출 → **MC89-E203**

### 3 Semantic Analysis

- [ ] 변수 스코프 관리 + 미정의 변수 → **MC89-E201**
- [ ] definite initialization 분석 + 미초기화 읽기 → **MC89-E202**
- [ ] 함수 심볼 테이블 구성 + 중복 정의 → **MC89-E403**
- [ ] 함수 호출 규칙:
  - forward call 금지 + 미정의 호출 → **MC89-E407**
  - 인자 개수 불일치 → **MC89-E408**
- [ ] `break/continue` 반복문 밖 사용 → **MC89-E303 / MC89-E304**
- [ ] `return;` 금지 정책 반영 → **MC89-E306**
- [ ] CTCE 판별 + 상수 접기:
  - 0으로 나누기 → **MC89-E206**
  - 오버플로 → **MC89-E207**
- [ ] 평가 순서 의존 표현식 정적 검출 → **MC89-E208**

### 4 Diagnostics Output

- [ ] 11.2 one-line format 강제:
  - `error|warning MC89-Exxx: message (line:col)`
- [ ] line/col 1-base 규칙 준수, Tab(HT)은 col+1로 계산
- [ ] 위치 특정 불가 시 `(0:0)` 사용

---

