# C89 초안

- [1. 서론](#1-서론)
  - [1.1 목적](#11-목적)
  - [1.2 적용 범위](#12-적용-범위)
  - [1.3 참고 문헌](#13-참고-문헌)
  - [1.4 문서의 구성](#14-문서의-구성)
  - [1.5 기초 문서](#15-기초-문서)
  - [1.6 용어의 정의](#16-용어의-정의)
  - [1.7 적합성](#17-적합성)
  - [1.8 향후 방향](#18-향후-방향)
  - [1.9 이 초안에 대하여](#19-이-초안에-대하여)
- [2. 환경](#2-환경)
  - [2.1 개념 모델](#21-개념-모델)
    - [2.1.1 번역 환경](#211-번역-환경)
      - [2.1.1.1 프로그램 구조](#2111-프로그램-구조)
      - [2.1.1.2 번역 단계](#2112-번역-단계)
      - [2.1.1.3 진단](#2113-진단)
    - [2.1.2 실행 환경](#212-실행-환경)
      - [2.1.2.1 독립 환경](#2121-독립-환경)
      - [2.1.2.2 호스트 환경](#2122-호스트-환경)
      - [2.1.2.3 프로그램 실행](#2123-프로그램-실행)
  - [2.2 환경 고려사항](#22-환경-고려사항)
    - [2.2.1 문자 집합](#221-문자-집합)
      - [2.2.1.1 삼중 문자 시퀀스](#2211-삼중-문자-시퀀스)
      - [2.2.1.2 멀티 바이트 문자](#2212-멀티-바이트-문자)
    - [2.2.2 문자 표시 의미론](#222-문자-표시-의미론)
    - [2.2.3 신호와 인터럽트](#223-신호와-인터럽트)
    - [2.2.4 환경 한계](#224-환경-한계)
      - [2.2.4.1 번역 한계](#2241-번역-한계)
      - [2.2.4.2 수치 한계](#2242-수치-한계)
- [3. 언어](#3-언어)
  - [3.1 어휘 요소](#31-어휘-요소)
    - [3.1.1 키워드](#311-키워드)
    - [3.1.2 식별자](#312-식별자)
      - [3.1.2.1 식별자의 유효 범위](#3121-식별자의-유효-범위)
      - [3.1.2.2 식별자의 연결](#3122-식별자의-연결)
      - [3.1.2.3 식별자의 이름 공간](#3123-식별자의-이름-공간)
      - [3.1.2.4 객체의 저장 기간](#3124-객체의-저장-기간)
      - [3.1.2.5 타입](#3125-타입)
      - [3.1.2.6 호환 타입과 합성 타입](#3126-호환-타입과-합성-타입)
    - [3.1.3 상수](#313-상수)
      - [3.1.3.1 실수 상수](#3131-실수-상수)
      - [3.1.3.2 정수 상수](#3132-정수-상수)
      - [3.1.3.3 열거 상수](#3133-열거-상수)
      - [3.1.3.4 문자 상수](#3134-문자-상수)
    - [3.1.4 문자열 리터럴](#314-문자열-리터럴)
    - [3.1.5 연산자](#315-연산자)
    - [3.1.6 구두점](#316-구두점)
    - [3.1.7 헤더 이름](#317-헤더-이름)
    - [3.1.8 전처리 숫자](#318-전처리-숫자)
    - [3.1.9 주석](#319-주석)
  - [3.2 변환](#32-변환)
    - [3.2.1 산술 피연산자](#321-산술-피연산자)
      - [3.2.1.1 문자와 정수](#3211-문자와-정수)
      - [3.2.1.2 부호 있는 정수와 부호 없는 정수](#3212-부호-있는-정수와-부호-없는-정수)
      - [3.2.1.3 실수과 정수](#3213-실수과-정수)
      - [3.2.1.4 실수 타입](#3214-실수-타입)
      - [3.2.1.5 일반 산술 변환](#3215-일반-산술-변환)
    - [3.2.2 기타 피연산자](#322-기타-피연산자)
      - [3.2.2.1 lvalue와 함수 지정자](#3221-lvalue와-함수-지정자)
      - [3.2.2.2 void](#3222-void)
      - [3.2.2.3 포인터](#3223-포인터)
  - [3.3 수식](#33-수식)
    - [3.3.1 기본 수식](#331-기본-수식)
    - [3.3.2 후위 연산자](#332-후위-연산자)
      - [3.3.2.1 배열 첨자](#3321-배열-첨자)
      - [3.3.2.2 함수 호출](#3322-함수-호출)
      - [3.3.2.3 구조체 및 공용체 멤버](#3323-구조체-및-공용체-멤버)
      - [3.3.2.4 후위 증감 연산자](#3324-후위-증감-연산자)
    - [3.3.3 단항 연산자](#333-단항-연산자)
      - [3.3.3.1 전위 증감 연산자](#3331-전위-증감-연산자)
      - [3.3.3.2 주소 및 간접 참조 연산자](#3332-주소-및-간접-참조-연산자)
      - [3.3.3.3 단항 산술 연산자](#3333-단항-산술-연산자)
      - [3.3.3.4 sizeof 연산자](#3334-sizeof-연산자)
    - [3.3.4 타입 변환 연산자](#334-타입-변환-연산자)
    - [3.3.5 곱셈 연산자](#335-곱셈-연산자)
    - [3.3.6 덧셈 연산자](#336-덧셈-연산자)
    - [3.3.7 비트 시프트 연산자](#337-비트-시프트-연산자)
    - [3.3.8 관계 연산자](#338-관계-연산자)
    - [3.3.9 등가 연산자](#339-등가-연산자)
    - [3.3.10 비트 AND 연산자](#3310-비트-and-연산자)
    - [3.3.11 비트 배타적 OR 연산자](#3311-비트-배타적-or-연산자)
    - [3.3.12 비트 포과적 OR 연산자](#3312-비트-포과적-or-연산자)
    - [3.3.13 논리 AND 연산자](#3313-논리-and-연산자)
    - [3.3.14 논리 OR 연산자](#3314-논리-or-연산자)
    - [3.3.15 조건 연산자](#3315-조건-연산자)
    - [3.3.16 대입 연산자](#3316-대입-연산자)
      - [3.3.16.1 단순 대입](#33161-단순-대입)
      - [3.3.16.2 복합 대입](#33162-복합-대입)
    - [3.3.17 쉼표 연산자](#3317-쉼표-연산자)
  - [3.4 상수 수식](#34-상수-수식)
  - [3.5 선언](#35-선언)
    - [3.5.1 저장 종류 지정자](#351-저장-종류-지정자)
    - [3.5.2 타입 지정자](#352-타입-지정자)
      - [3.5.2.1 구조체 및 공용체 지정자](#3521-구조체-및-공용체-지정자)
      - [3.5.2.2 열거체 지정자](#3522-열거체-지정자)
      - [3.5.2.3 태그](#3523-태그)
    - [3.5.3 타입 한정자](#353-타입-한정자)
    - [3.5.4 선언자](#354-선언자)
      - [3.5.4.1 포인터 선언자](#3541-포인터-선언자)
      - [3.5.4.2 배열 선언자](#3542-배열-선언자)
      - [3.5.4.3 함수 선언자(프로토타입 포함)](#3543-함수-선언자프로토타입-포함)
    - [3.5.5 타입 이름](#355-타입-이름)
    - [3.5.6 타입 정의](#356-타입-정의)
    - [3.5.7 초기화](#357-초기화)
  - [3.6 문장](#36-문장)
    - [3.6.1 라벨이 붙은 문장](#361-라벨이-붙은-문장)
    - [3.6.2 복합문 또는 블록](#362-복합문-또는-블록)
    - [3.6.3 수식문과 null 문](#363-수식문과-null-문)
    - [3.6.4 선택문](#364-선택문)
      - [3.6.4.1 if 문](#3641-if-문)
      - [3.6.4.2 switch 문](#3642-switch-문)
    - [3.6.5 반복문](#365-반복문)
      - [3.6.5.1 while 문](#3651-while-문)
      - [3.6.5.2 do 문](#3652-do-문)
      - [3.6.5.3 for 문](#3653-for-문)
    - [3.6.6 점프문](#366-점프문)
      - [3.6.6.1 goto 문](#3661-goto-문)
      - [3.6.6.2 continue 문](#3662-continue-문)
      - [3.6.6.3 break 문](#3663-break-문)
      - [3.6.6.4 return 문](#3664-return-문)
  - [3.7 외부 정의](#37-외부-정의)
    - [3.7.1 함수 정의](#371-함수-정의)
    - [3.7.2 외부 객체 정의](#372-외부-객체-정의)
  - [3.8 전처리 지시문](#38-전처리-지시문)
    - [3.8.1 조건부 포함](#381-조건부-포함)
    - [3.8.2 소스 파일 포함](#382-소스-파일-포함)
    - [3.8.3 매크로 치환](#383-매크로-치환)
      - [3.8.3.1 인자 치환](#3831-인자-치환)
      - [3.8.3.2 # 연산자](#3832--연산자)
      - [3.8.3.3 ## 연산자](#3833--연산자)
      - [3.8.3.4 재스캔 및 추가 치환](#3834-재스캔-및-추가-치환)
      - [3.8.3.5 매크로 정의의 범위](#3835-매크로-정의의-범위)
    - [3.8.4 줄 제어](#384-줄-제어)
    - [3.8.5 에러 지시문](#385-에러-지시문)
    - [3.8.6 pragma 지시문](#386-pragma-지시문)
    - [3.8.7 null 지시문](#387-null-지시문)
    - [3.8.8 미리 정의된 매크로 이름](#388-미리-정의된-매크로-이름)
  - [3.9 향후 언어 방향](#39-향후-언어-방향)
    - [3.9.1 외부 이름](#391-외부-이름)
    - [3.9.2 문자 이스케이프 시퀀스](#392-문자-이스케이프-시퀀스)
    - [3.9.3 저장 클래스 지정자](#393-저장-클래스-지정자)
    - [3.9.4 함수 선언자](#394-함수-선언자)
    - [3.9.5 함수 정의](#395-함수-정의)
- [4. 라이브러리](#4-라이브러리)
  - [4.1 개요](#41-개요)
    - [4.1.1 용어의 정의](#411-용어의-정의)
    - [4.1.2 표준 헤더](#412-표준-헤더)
    - [4.1.3 에러 <errno.h>](#413-에러-errnoh)
    - [4.1.4 한계값 <float.h> 및 <limits.h>](#414-한계값-floath-및-limitsh)
    - [4.1.5 공통 정의 <stddef.h>](#415-공통-정의-stddefh)
    - [4.1.6 라이브러리 함수 사용](#416-라이브러리-함수-사용)
  - [4.2 진단 <assert.h>](#42-진단-asserth)
    - [4.2.1 프로그램 진단](#421-프로그램-진단)
      - [4.2.1.1 assert 매크로](#4211-assert-매크로)
  - [4.3 문자 처리 <ctype.h>](#43-문자-처리-ctypeh)
    - [4.3.1 문자 검사 함수](#431-문자-검사-함수)
      - [4.3.1.1 isalnum 함수](#4311-isalnum-함수)
      - [4.3.1.2 isalpha 함수](#4312-isalpha-함수)
      - [4.3.1.3 iscntrl 함수](#4313-iscntrl-함수)
      - [4.3.1.4 isdigit 함수](#4314-isdigit-함수)
      - [4.3.1.5 isgraph 함수](#4315-isgraph-함수)
      - [4.3.1.6 islower 함수](#4316-islower-함수)
      - [4.3.1.7 isprint 함수](#4317-isprint-함수)
      - [4.3.1.8 ispunct 함수](#4318-ispunct-함수)
      - [4.3.1.9 isspace 함수](#4319-isspace-함수)
      - [4.3.1.10 isupper 함수](#43110-isupper-함수)
      - [4.3.1.11 isxdigit 함수](#43111-isxdigit-함수)
    - [4.3.2 문자 대소문자 매핑 함수](#432-문자-대소문자-매핑-함수)
      - [4.3.2.1 tolower 함수](#4321-tolower-함수)
      - [4.3.2.2 toupper 함수](#4322-toupper-함수)
  - [4.4 국제화 <locale.h>](#44-국제화-localeh)
    - [4.4.1 locale 제어](#441-locale-제어)
      - [4.4.1.1 setlocale 함수](#4411-setlocale-함수)
    - [4.4.2 숫자 서식 관례 조회](#442-숫자-서식-관례-조회)
      - [4.4.2.1 localeconv 함수](#4421-localeconv-함수)
  - [4.5 수학 <math.h>](#45-수학-mathh)
    - [4.5.1 에러 조건 처리](#451-에러-조건-처리)
    - [4.5.2 삼각 함수](#452-삼각-함수)
      - [4.5.2.1 acos 함수](#4521-acos-함수)
      - [4.5.2.2 asin 함수](#4522-asin-함수)
      - [4.5.2.3 atan 함수](#4523-atan-함수)
      - [4.5.2.4 atan2 함수](#4524-atan2-함수)
      - [4.5.2.5 cos 함수](#4525-cos-함수)
      - [4.5.2.6 sin 함수](#4526-sin-함수)
      - [4.5.2.7 tan 함수](#4527-tan-함수)
    - [4.5.3 쌍곡선 함수](#453-쌍곡선-함수)
      - [4.5.3.1 cosh 함수](#4531-cosh-함수)
      - [4.5.3.2 sinh 함수](#4532-sinh-함수)
      - [4.5.3.3 tanh 함수](#4533-tanh-함수)
    - [4.5.4 지수 및 로그 함수](#454-지수-및-로그-함수)
      - [4.5.4.1 exp 함수](#4541-exp-함수)
      - [4.5.4.2 frexp 함수](#4542-frexp-함수)
      - [4.5.4.3 ldexp 함수](#4543-ldexp-함수)
      - [4.5.4.4 log 함수](#4544-log-함수)
      - [4.5.4.5 log10 함수](#4545-log10-함수)
      - [4.5.4.6 modf 함수](#4546-modf-함수)
    - [4.5.5 거듭제곱 함수](#455-거듭제곱-함수)
      - [4.5.5.1 pow 함수](#4551-pow-함수)
      - [4.5.5.2 sqrt 함수](#4552-sqrt-함수)
    - [4.5.6 근접 정수, 절댓값, 나머지 함수](#456-근접-정수-절댓값-나머지-함수)
      - [4.5.6.1 ceil 함수](#4561-ceil-함수)
      - [4.5.6.2 fabs 함수](#4562-fabs-함수)
      - [4.5.6.3 floor 함수](#4563-floor-함수)
      - [4.5.6.4 fmod 함수](#4564-fmod-함수)
  - [4.6 비지역 점프 <setjmp.h>](#46-비지역-점프-setjmph)
    - [4.6.1 호출 환경 저장](#461-호출-환경-저장)
      - [4.6.1.1 setjmp 매크로](#4611-setjmp-매크로)
    - [4.6.2 호출 환경 복원](#462-호출-환경-복원)
      - [4.6.2.1 longjmp 함수](#4621-longjmp-함수)
  - [4.7 신호 처리 <signal.h>](#47-신호-처리-signalh)
    - [4.7.1 신호 처리 지정](#471-신호-처리-지정)
      - [4.7.1.1 signal 함수](#4711-signal-함수)
    - [4.7.2 신호 보내기](#472-신호-보내기)
      - [4.7.2.1 raise 함수](#4721-raise-함수)
  - [4.8 가변 인자(variable arguments) <stdarg.h>](#48-가변-인자variable-arguments-stdargh)
    - [4.8.1 가변 인자 리스트 접근 매크로](#481-가변-인자-리스트-접근-매크로)
      - [4.8.1.1 va_start 매크로](#4811-va_start-매크로)
      - [4.8.1.2 va_arg 매크로](#4812-va_arg-매크로)
      - [4.8.1.3 va_end 매크로](#4813-va_end-매크로)
  - [4.9 입출력 <stdio.h>](#49-입출력-stdioh)
    - [4.9.1 개요](#491-개요)
    - [4.9.2 스트림](#492-스트림)
    - [4.9.3 파일](#493-파일)
    - [4.9.4 파일에 대한 연산](#494-파일에-대한-연산)
      - [4.9.4.1 remove 함수](#4941-remove-함수)
      - [4.9.4.2 rename 함수](#4942-rename-함수)
      - [4.9.4.3 tmpfile 함수](#4943-tmpfile-함수)
      - [4.9.4.4 tmpnam 함수](#4944-tmpnam-함수)
    - [4.9.5 파일 접근 함수](#495-파일-접근-함수)
      - [4.9.5.1 fclose 함수](#4951-fclose-함수)
      - [4.9.5.2 fflush 함수](#4952-fflush-함수)
      - [4.9.5.3 fopen 함수](#4953-fopen-함수)
      - [4.9.5.4 freopen 함수](#4954-freopen-함수)
      - [4.9.5.5 setbuf 함수](#4955-setbuf-함수)
      - [4.9.5.6 setvbuf 함수](#4956-setvbuf-함수)
    - [4.9.6 형식 지정 입출력 함수](#496-형식-지정-입출력-함수)
      - [4.9.6.1 fprintf 함수](#4961-fprintf-함수)
      - [4.9.6.2 fscanf 함수](#4962-fscanf-함수)
      - [4.9.6.3 printf 함수](#4963-printf-함수)
      - [4.9.6.4 scanf 함수](#4964-scanf-함수)
      - [4.9.6.5 sprintf 함수](#4965-sprintf-함수)
      - [4.9.6.6 sscanf 함수](#4966-sscanf-함수)
      - [4.9.6.7 vfprintf 함수](#4967-vfprintf-함수)
      - [4.9.6.8 vprintf 함수](#4968-vprintf-함수)
      - [4.9.6.9 vsprintf 함수](#4969-vsprintf-함수)
    - [4.9.7 문자 입출력 함수](#497-문자-입출력-함수)
      - [4.9.7.1 fgetc 함수](#4971-fgetc-함수)
      - [4.9.7.2 fgets 함수](#4972-fgets-함수)
      - [4.9.7.3 fputc 함수](#4973-fputc-함수)
      - [4.9.7.4 fputs 함수](#4974-fputs-함수)
      - [4.9.7.5 getc 함수](#4975-getc-함수)
      - [4.9.7.6 getchar 함수](#4976-getchar-함수)
      - [4.9.7.7 gets 함수](#4977-gets-함수)
      - [4.9.7.8 putc 함수](#4978-putc-함수)
      - [4.9.7.9 putchar 함수](#4979-putchar-함수)
      - [4.9.7.10 puts 함수](#49710-puts-함수)
      - [4.9.7.11 ungetc 함수](#49711-ungetc-함수)
    - [4.9.8 직접 입출력 함수](#498-직접-입출력-함수)
      - [4.9.8.1 fread 함수](#4981-fread-함수)
      - [4.9.8.2 fwrite 함수](#4982-fwrite-함수)
    - [4.9.9 파일 위치 지정 함수](#499-파일-위치-지정-함수)
      - [4.9.9.1 fgetpos 함수](#4991-fgetpos-함수)
      - [4.9.9.2 fseek 함수](#4992-fseek-함수)
      - [4.9.9.3 fsetpos 함수](#4993-fsetpos-함수)
      - [4.9.9.4 ftell 함수](#4994-ftell-함수)
      - [4.9.9.5 rewind 함수](#4995-rewind-함수)
    - [4.9.10 에러 처리 함수](#4910-에러-처리-함수)
      - [4.9.10.1 clearerr 함수](#49101-clearerr-함수)
      - [4.9.10.2 feof 함수](#49102-feof-함수)
      - [4.9.10.3 ferror 함수](#49103-ferror-함수)
      - [4.9.10.4 perror 함수](#49104-perror-함수)
  - [4.10 일반 유틸리티 <stdlib.h>](#410-일반-유틸리티-stdlibh)
    - [4.10.1 문자열 변환 함수](#4101-문자열-변환-함수)
      - [4.10.1.1 atof 함수](#41011-atof-함수)
      - [4.10.1.2 atoi 함수](#41012-atoi-함수)
      - [4.10.1.3 atol 함수](#41013-atol-함수)
      - [4.10.1.4 strtod 함수](#41014-strtod-함수)
      - [4.10.1.5 strtol 함수](#41015-strtol-함수)
      - [4.10.1.6 strtoul 함수](#41016-strtoul-함수)
    - [4.10.2 의사 난수 수열 생성 함수](#4102-의사-난수-수열-생성-함수)
      - [4.10.2.1 rand 함수](#41021-rand-함수)
      - [4.10.2.2 srand 함수](#41022-srand-함수)
    - [4.10.3 메모리 관리 함수](#4103-메모리-관리-함수)
      - [4.10.3.1 calloc 함수](#41031-calloc-함수)
      - [4.10.3.2 free 함수](#41032-free-함수)
      - [4.10.3.3 malloc 함수](#41033-malloc-함수)
      - [4.10.3.4 realloc 함수](#41034-realloc-함수)
    - [4.10.4 환경과의 통신](#4104-환경과의-통신)
      - [4.10.4.1 abort 함수](#41041-abort-함수)
      - [4.10.4.2 atexit 함수](#41042-atexit-함수)
      - [4.10.4.3 exit 함수](#41043-exit-함수)
      - [4.10.4.4 getenv 함수](#41044-getenv-함수)
      - [4.10.4.5 system 함수](#41045-system-함수)
    - [4.10.5 검색 및 정렬 유틸리티](#4105-검색-및-정렬-유틸리티)
      - [4.10.5.1 bsearch 함수](#41051-bsearch-함수)
      - [4.10.5.2 qsort 함수](#41052-qsort-함수)
    - [4.10.6 정수 산술 함수](#4106-정수-산술-함수)
      - [4.10.6.1 abs 함수](#41061-abs-함수)
      - [4.10.6.2 div 함수](#41062-div-함수)
      - [4.10.6.3 labs 함수](#41063-labs-함수)
      - [4.10.6.4 ldiv 함수](#41064-ldiv-함수)
    - [4.10.7 멀티 바이트 문자 함수](#4107-멀티-바이트-문자-함수)
      - [4.10.7.1 mblen 함수](#41071-mblen-함수)
      - [4.10.7.2 mbtowc 함수](#41072-mbtowc-함수)
      - [4.10.7.3 wctomb 함수](#41073-wctomb-함수)
    - [4.10.8 멀티 바이트 문자열 함수](#4108-멀티-바이트-문자열-함수)
      - [4.10.8.1 mbstowcs 함수](#41081-mbstowcs-함수)
      - [4.10.8.2 wcstombs 함수](#41082-wcstombs-함수)
  - [4.11 문자열 처리 <string.h>](#411-문자열-처리-stringh)
    - [4.11.1 문자열 함수 규약](#4111-문자열-함수-규약)
    - [4.11.2 복사 함수](#4112-복사-함수)
      - [4.11.2.1 memcpy 함수](#41121-memcpy-함수)
      - [4.11.2.2 memmove 함수](#41122-memmove-함수)
      - [4.11.2.3 strcpy 함수](#41123-strcpy-함수)
      - [4.11.2.4 strncpy 함수](#41124-strncpy-함수)
    - [4.11.3 연결 함수](#4113-연결-함수)
      - [4.11.3.1 strcat 함수](#41131-strcat-함수)
      - [4.11.3.2 strncat 함수](#41132-strncat-함수)
    - [4.11.4 비교 함수](#4114-비교-함수)
      - [4.11.4.1 memcmp 함수](#41141-memcmp-함수)
      - [4.11.4.2 strcmp 함수](#41142-strcmp-함수)
      - [4.11.4.3 strcoll 함수](#41143-strcoll-함수)
      - [4.11.4.4 strncmp 함수](#41144-strncmp-함수)
      - [4.11.4.5 strxfrm 함수](#41145-strxfrm-함수)
    - [4.11.5 검색 함수](#4115-검색-함수)
      - [4.11.5.1 memchr 함수](#41151-memchr-함수)
      - [4.11.5.2 strchr 함수](#41152-strchr-함수)
      - [4.11.5.3 strcspn 함수](#41153-strcspn-함수)
      - [4.11.5.4 strpbrk 함수](#41154-strpbrk-함수)
      - [4.11.5.5 strrchr 함수](#41155-strrchr-함수)
      - [4.11.5.6 strspn 함수](#41156-strspn-함수)
      - [4.11.5.7 strstr 함수](#41157-strstr-함수)
      - [4.11.5.8 strtok 함수](#41158-strtok-함수)
    - [4.11.6 기타 함수](#4116-기타-함수)
      - [4.11.6.1 memset 함수](#41161-memset-함수)
      - [4.11.6.2 strerror 함수](#41162-strerror-함수)
      - [4.11.6.3 strlen 함수](#41163-strlen-함수)
  - [4.12 날짜와 시간 <time.h>](#412-날짜와-시간-timeh)
    - [4.12.1 시간의 구성 요소](#4121-시간의-구성-요소)
    - [4.12.2 시간 조작 함수](#4122-시간-조작-함수)
      - [4.12.2.1 clock 함수](#41221-clock-함수)
      - [4.12.2.2 difftime 함수](#41222-difftime-함수)
      - [4.12.2.3 mktime 함수](#41223-mktime-함수)
      - [4.12.2.4 time 함수](#41224-time-함수)
    - [4.12.3 시간 변환 함수](#4123-시간-변환-함수)
      - [4.12.3.1 asctime 함수](#41231-asctime-함수)
      - [4.12.3.2 ctime 함수](#41232-ctime-함수)
      - [4.12.3.3 gmtime 함수](#41233-gmtime-함수)
      - [4.12.3.4 localtime 함수](#41234-localtime-함수)
      - [4.12.3.5 strftime 함수](#41235-strftime-함수)
  - [4.13 향후 라이브러리 방향](#413-향후-라이브러리-방향)
    - [4.13.1 에러 <errno.h>](#4131-에러-errnoh)
    - [4.13.2 문자 처리 <ctype.h>](#4132-문자-처리-ctypeh)
    - [4.13.3 지역화 <locale.h>](#4133-지역화-localeh)
    - [4.13.4 수학 <math.h>](#4134-수학-mathh)
    - [4.13.5 신호 처리 <signal.h>](#4135-신호-처리-signalh)
    - [4.13.6 입출력 <stdio.h>](#4136-입출력-stdioh)
    - [4.13.7 일반 유틸리티 <stdlib.h>](#4137-일반-유틸리티-stdlibh)
    - [4.13.8 문자열 처리 <string.h>](#4138-문자열-처리-stringh)
- [A. 부록](#a-부록)
  - [A.1 언어 구문 요약](#a1-언어-구문-요약)
    - [A.1.1 어휘 문법](#a11-어휘-문법)
      - [A.1.1.1 토큰](#a111-토큰)
      - [A.1.1.2 키워드](#a112-키워드)
      - [A.1.1.3 식별자](#a113-식별자)
      - [A.1.1.4 상수](#a114-상수)
      - [A.1.1.5 문자열 리터럴](#a115-문자열-리터럴)
      - [A.1.1.6 연산자](#a116-연산자)
      - [A.1.1.7 구두점](#a117-구두점)
      - [A.1.1.8 헤더 이름](#a118-헤더-이름)
      - [A.1.1.9 전처리 숫자](#a119-전처리-숫자)
    - [A.1.2 구문 구조 문법](#a12-구문-구조-문법)
      - [A.1.2.1 수식](#a121-수식)
      - [A.1.2.2 선언](#a122-선언)
      - [A.1.2.3 문장](#a123-문장)
      - [A.1.2.4 외부 정의](#a124-외부-정의)
    - [A.1.3 전처리 지시문](#a13-전처리-지시문)
  - [A.2 시퀀스 포인트](#a2-시퀀스-포인트)
  - [A.3 라이브러리 요약](#a3-라이브러리-요약)
    - [A.3.1 에러 <errno.h>](#a31-에러-errnoh)
    - [A.3.2 공통 정의 <stddef.h>](#a32-공통-정의-stddefh)
    - [A.3.3 진단 <assert.h>](#a33-진단-asserth)
    - [A.3.4 문자 처리 <ctype.h>](#a34-문자-처리-ctypeh)
    - [A.3.5 지역화 <locale.h>](#a35-지역화-localeh)
    - [A.3.6 수학 <math.h>](#a36-수학-mathh)
    - [A.3.7 비지역 점프 <setjmp.h>](#a37-비지역-점프-setjmph)
    - [A.3.8 신호 처리 <signal.h>](#a38-신호-처리-signalh)
    - [A.3.9 가변 인자 <stdarg.h>](#a39-가변-인자-stdargh)
    - [A.3.10 입출력 <stdio.h>](#a310-입출력-stdioh)
    - [A.3.11 일반 유틸리티 <stdlib.h>](#a311-일반-유틸리티-stdlibh)
    - [A.3.12 문자열 처리 <string.h>](#a312-문자열-처리-stringh)
    - [A.3.13 날짜와 시간 <time.h>](#a313-날짜와-시간-timeh)
  - [A.4 구현 한계](#a4-구현-한계)
  - [A.5 공통 경고](#a5-공통-경고)
  - [A.6 이식성 문제](#a6-이식성-문제)
    - [A.6.1 미지정 동작](#a61-미지정-동작)
    - [A.6.2 정의되지 않은 동작](#a62-정의되지-않은-동작)
    - [A.6.3 구현 정의 동작](#a63-구현-정의-동작)
      - [A.6.3.1 환경](#a631-환경)
      - [A.6.3.2 식별자](#a632-식별자)
      - [A.6.3.3 문자](#a633-문자)
      - [A.6.3.4 정수](#a634-정수)
      - [A.6.3.5 실수](#a635-실수)
      - [A.6.3.6 배열과 포인터](#a636-배열과-포인터)
      - [A.6.3.7 레지스터](#a637-레지스터)
      - [A.6.3.8 구조체, 공용체, 열거 타입, 비트 필드](#a638-구조체-공용체-열거-타입-비트-필드)
      - [A.6.3.9 한정자](#a639-한정자)
      - [A.6.3.10 선언자](#a6310-선언자)
      - [A.6.3.11 문장](#a6311-문장)
      - [A.6.3.12 전처리 지시문](#a6312-전처리-지시문)
      - [A.6.3.13 라이브러리 함수](#a6313-라이브러리-함수)
    - [A.6.4 로케일 특화 동작](#a64-로케일-특화-동작)
    - [A.6.5 일반적인 확장](#a65-일반적인-확장)
      - [A.6.5.1 환경 인자](#a651-환경-인자)
      - [A.6.5.2 특수 식별자](#a652-특수-식별자)
      - [A.6.5.3 식별자의 길이와 대/소문자](#a653-식별자의-길이와-대소문자)
      - [A.6.5.4 식별자의 유효 범위](#a654-식별자의-유효-범위)
      - [A.6.5.5 쓰기 가능한 문자열 리터럴](#a655-쓰기-가능한-문자열-리터럴)
      - [A.6.5.6 기타 산술 타입](#a656-기타-산술-타입)
      - [A.6.5.7 함수 포인터 타입 변환](#a657-함수-포인터-타입-변환)
      - [A.6.5.8 int가 아닌 비트 필드 타입](#a658-int가-아닌-비트-필드-타입)
      - [A.6.5.9 fortran 키워드](#a659-fortran-키워드)
      - [A.6.5.10 asm 키워드](#a6510-asm-키워드)
      - [A.6.5.11 다중 외부 정의](#a6511-다중-외부-정의)
      - [A.6.5.12 빈 매크로 인자](#a6512-빈-매크로-인자)
      - [A.6.5.13 미리 정의된 매크로 이름](#a6513-미리-정의된-매크로-이름)
      - [A.6.5.14 신호 처리기에 대한 추가 인자](#a6514-신호-처리기에-대한-추가-인자)
      - [A.6.5.15 추가 스트림 유형 및 파일 열기 모드](#a6515-추가-스트림-유형-및-파일-열기-모드)
      - [A.6.5.16 정의된 파일 위치 표시자](#a6516-정의된-파일-위치-표시자)
  - [A.7 색인](#a7-색인)

(이 머리말은 정보 시스템용 미국 국가 표준 — 프로그래밍 언어 C, X3.???-1988의 일부가 아니다.)

미국 국가 표준 프로그래밍 언어 C는 C 프로그래밍 언어로 작성된 프로그램의 구문과 의미론을 규정한다. 또한 입출력 데이터를 통해 실행 환경과 C 프로그램이 상호작용하는 방식을 규정한다. 아울러, C 언어 번역기의 적합 구현에 부과되는 제약 사항과 한계도 규정한다.

이 표준은 미국 국가 표준 위원회 컴퓨터 및 정보 처리 분과(X3) 산하의 프로젝트 381-D에 따라, C 프로그래밍 언어에 관한 X3J11 기술위원회가 개발하였다. 표준 기획 및 요구사항 위원회 문서 번호 83-079는 이 프로젝트의 목적을 "언어 C에 대한 모호하지 않고 기계 독립적인 정의를 제공하는 것"이라고 설명한다.

C 프로그래밍 언어의 사용이 급속히 확대되고, 서로 다른 번역기 구현들이 이미 개발되었거나 개발되고 있었기 때문에, C 공동체에서는 명확하게 정의된 단일 표준의 필요성이 대두되었다. 서로 유사하지만 호환되지 않는 구현들이 존재한다는 사실은, 여러 서로 다른 환경에서 예상대로 컴파일되고 실행되는 코드를 개발하고자 하는 프로그램 개발자들에게 심각한 문제였다.

이 문제의 일부는, 구현자들이 자신의 구현을 기반으로 삼을 만한 충분한 C 언어 정의를 갖고 있지 못했다는 사실로 거슬러 올라갈 수 있다. 사실상의 C 프로그래밍 언어 표준인 브라이언 W. 커니핸과 데니스 M. 리치의 The C Programming Language는 훌륭한 책이지만, C 언어를 완전히 규정하기에는 정밀성이나 완전성이 충분하지 않다. 또한 이 언어는 수년간 사용되는 동안 새로운 프로그래밍 아이디어를 수용하고 원래 언어의 몇몇 약점을 보완하기 위해 발전해 왔다.

미국 국가 표준 프로그래밍 언어 C는 C 언어를 정확하게 규정함으로써, 프로그램 개발자와 번역기 구현자 모두의 문제를 해결한다.

X3J11의 작업은 1983년 여름에, 위원회에 제공된 여러 문서([1.5 기본 문서](#15-기본-문서) 참조)를 바탕으로 시작되었다. 위원회는 이 작업을 환경, 언어, 라이브러리의 세 부분으로 나누었다. 진정으로 이식 가능한 프로그램을 개발하려면 이들 각 영역에 대한 완전한 명세가 필요하다. 표준은 이들 각 영역을 모두 다룬다. 위원회는 심의 과정에서 기본 문서에 대한 추가, 삭제, 변경 제안들을 다수 평가하였다. 모호하지 않고 일관된 관행이 확인될 수 있는 곳에서는, 기존 관행을 성문화 하기 위해 공동의 노력이 이루어졌다. 그러나 일관된 관행을 확인할 수 없는 경우에는, 위원회는 언어의 전반적인 성격과 조화를 이루는 명확한 규칙을 수립하기 위해 노력하였다.

이 문서는 1988년 DD MM에 미국 국가 표준 협회에 의해 미국 국가 표준으로 승인되었다. 이 표준의 개선을 위한 제안은 환영한다. 제안은 미국 국가 표준 협회 주소로 보내야 한다: American National Standards Institute, 1430 Broadway, New York, NY 10018.

이 표준은 컴퓨터 및 정보 처리에 관한 미국 국가 표준 위원회 X3에 의해 처리되었고, ANSI에 제출하기 위해 승인되었다. 위원회가 표준을 승인했다고 해서, 반드시 모든 위원이 그 승인에 찬성표를 던졌음을 의미하는 것은 아니다. 이 표준을 승인했을 당시 X3 위원회는 다음과 같은 위원들로 구성되어 있었다:

대표자 소속 기관명(표준 승인 전까지 완성될 예정.)

C 프로그래밍 언어에 관한 기술위원회 X3J11은 이 문서를 미국 국가 표준으로 처리하도록 X3에 제출했을 당시 다음과 같은 위원들로 구성되어 있었다:

|  |  |  |
| :--- | :--- | :--- |
| **의장** | 짐 브로디 | |
| **부의장** | 토마스 플럼 | 플럼 홀 |
| **서기** | P. J. 플로거 | 화이트스미스 |
| **국제 대표** | P. J. 플로거<br>스티브 허시 | 화이트스미스<br>래티스 |
| **용어 대표** | 앤드류 존슨 | 프라임 컴퓨터 |
| **환경 분과위원장** | 랄프 라이언<br>랄프 프레이너 | 마이크로소프트<br>프레이너 어소시에이츠 |
| **언어 분과위원장** | 로렌스 로슬러 | AT&T |
| **라이브러리 분과위원장** | P. J. 플로거 | 화이트스미스 |
| **초안 편집자** | 데이비드 F. 프로서<br>로렌스 로슬러 | AT&T<br>AT&T |
| **해설서 편집자** | 랜디 허드슨 | 인터메트릭스 |

다음 목록에서 별도의 표시가 없는 이름은 정위원을, * 표시는 대체 위원을 나타낸다.

|  |  |
| :--- | :--- |
| **데이비드 F. 프로서** | AT&T |
| **스티븐 J. 아담스키*** | AT&T *(X3H2 SQL 연락책)* |
| **밥 고틀립** | 얼라이언트 컴퓨터 시스템즈 |
| **케빈 브로스넌** | 얼라이언트 컴퓨터 시스템즈 |
| **닐 와이든호퍼** | 암달 |
| **필립 C. 스틸** | 아메리칸 심플렉스 |
| **에릭 맥글로혼*** | 아메리칸 심플렉스 |
| **스티븐 카프카** | 아날로그 디바이스 |
| **케빈 리어리*** | 아날로그 디바이스 |
| **고든 스털링*** | 아날로그 디바이스 |
| **존 페이튼** | 아폴로 컴퓨터 |
| **엘리자베스 크로켓** | 애플 컴퓨터 |
| **에드 웰스** | 아링크 |
| **톰 케터하겐*** | 아링크 |
| **본 버논** | 아스펜 사이언티픽 |
| **크레이그 보들론** | 벨 커뮤니케이션즈 리서치 |
| **스티브 카터*** | 벨 커뮤니케이션즈 리서치 |
| **윌리엄 푸이그*** | 벨 커뮤니케이션즈 리서치 |
| **밥 자비스** | 볼랜드 인터내셔널 |
| **욤-토브 메게드** | 보스턴 시스템즈 오피스 |
| **로즈 톰슨*** | 보스턴 시스템즈 오피스 |
| **모리스 파티** | COSMIC |
| **존 우** | 찰스 리버 데이터 시스템즈 |
| **다니엘 미키** | 케미컬 앱스트랙트 서비스 |
| **토마스 밈리치*** | 케미컬 앱스트랙트 서비스 |
| **앨런 로소프** | 시카고 리서치 & 트레이딩 그룹 |
| **에드워드 브릭스** | 씨티은행 |
| **피르모 프레이레** | 코브라 S/A |
| **짐 패터슨** | 코그노스 |
| **브루스 테텔만** | 컬럼비아대 컴퓨팅 센터 |
| **테리 무어** | 컴퓨다스 |
| **마크 바레네시아** | 컴퓨터 어소시에이츠 |
| **조지 에버하르트** | 컴퓨터 이노베이션즈 |
| **데이브 네더리*** | 컴퓨터 이노베이션즈 |
| **조셉 비보** | 컴퓨트리션 |
| **스티브 데이비스** | 컨커런트 컴퓨터 코퍼레이션 |
| **돈 포스버리** | 컨트롤 데이터 |
| **조지 밴드번트*** | 컨트롤 데이터 |
| **로이드 아이언스** | 코모란트 커뮤니케이션즈 |
| **톰 맥도날드** | 크레이 리서치 |
| **린 존슨*** | 크레이 리서치 |
| **데이브 베커*** | 크레이 리서치 |
| **진 리슬리** | 커스텀 디벨롭먼트 인바이런먼츠 |
| **렉스 자슈케** | DEC 프로페셔널 |
| **마이크 테라자스** | DECUS 대표 |
| **마이클 마이스너** | 데이터 제너럴 |
| **마크 해리스*** | 데이터 제너럴 |
| **레오나드 옴스** | 데이터포인트 |
| **제임스 스탠리** | 데이터 시스템즈 애널리스트 |
| **사무엘 J. 켄달** | 델프트 컨설팅 |
| **랜디 마이어스** | 디지털 이큅먼트 코퍼레이션 (DEC) |
| **아트 비요크*** | 디지털 이큅먼트 코퍼레이션 (DEC) |
| **루 앤 반 드 파스*** | 디지털 이큅먼트 코퍼레이션 (DEC) |
| **벤 파텔** | EDS |
| **리처드 렐프** | EPI |
| **그레이엄 앤드류스** | 에든버러 포터블 컴파일러 |
| **콜린 맥페일*** | 에든버러 포터블 컴파일러 |
| **J. 스티븐 아담칙** | 에디슨 디자인 그룹 |
| **에릭 슈워츠*** | 에디슨 디자인 그룹 |
| **드미트리 렌코프** | 에베레스트 솔루션즈 |
| **프랭크 패런스** | 패런스 Inc. |
| **피터 헤이즈*** | 패런스 Inc. |
| **플로린 조던** | 플로라딘 |
| **필립 프로빈** | 제너럴 일렉트릭 정보 서비스 |
| **리즈 샌빌** | 굴드 CSD |
| **티나 알렉사*** | 굴드 CSD |
| **토마스 켈리** | HCR 코퍼레이션 |
| **폴 잭슨*** | HCR 코퍼레이션 |
| **게리 지터** | 해리스 컴퓨터 시스템즈 |
| **수 멜로이** | 휴렛 패커드 |
| **래리 로슬러*** | 휴렛 패커드 |
| **미셸 루세타*** | 휴렛 패커드 |
| **토마스 E. 오스틴** | 허니웰 정보 시스템 |
| **데이비드 케이든*** | 허니웰 정보 시스템 |
| **숀 엘리엇** | IBM |
| **래리 브리드*** | IBM |
| **멜 골드버그*** | IBM |
| **마이크 바나한** | 인스트럭션 세트 |
| **클라크 넬슨** | 인텔 |
| **댄 라우*** | 인텔 |
| **존 울프** | 인터랙트 |
| **릴리안 톨*** | 인터랙트 |
| **랜디 허드슨** | 인터메트릭스 |
| **키스 윈터** | 인터내셔널 컴퓨터 |
| **허니 M. 슈레커*** | 인터내셔널 컴퓨터 |
| **짐 브로디** | J. 브로디 & 어소시에이츠 |
| **재클린 코티키안** | 켄달 스퀘어 리서치 |
| **W. 피터 헤세** | LSI 로직 유럽 |
| **존 카민스키** | 랭귀지 프로세서 Inc. |
| **데이비드 요스트** | 로렐 아츠 |
| **마이크 브랜스테터** | 로렌스 리버모어 국립 연구소 |
| **밥 위버** | 로스 알라모스 국립 연구소 |
| **리디아 에버하트** | 모드컴 |
| **로버트 셰리** | 맹크스 소프트웨어 |
| **코트니 마이센** | 마크 윌리엄스 Co. |
| **패트리샤 젠킨스** | 매스컴 |
| **데이브 힌만*** | 매스컴 |
| **마이클 컨스** | 메타링크 |
| **톰 페넬로** | 메타웨어 |
| **데이비드 F. 웨일** | 마이크로소프트 |
| **미치 하더*** | 마이크로소프트 |
| **킴 켐프** | 마이크로웨어 시스템즈 |
| **셰인 매캐런** | 미네소타 교육 컴퓨팅 |
| **브루스 올슨** | 모자이크 테크놀로지 |
| **마이클 패튼** | 모토로라 |
| **릭 슈버트** | NCR |
| **브라이언 존슨*** | NCR |
| **조셉 뮬러** | 내셔널 세미컨덕터 |
| **데릭 갓프리*** | 내셔널 세미컨덕터 |
| **짐 어퍼맨** | 국립 표준국 |
| **제임스 W. 윌리엄스** | 해군 연구소 |
| **리사 사이먼** | OCLC |
| **폴 아마란스** | 오클랜드 대학교 |
| **어거스트 R. 핸슨** | 옴니웨어 |
| **마이클 롤** | 오라클 |
| **칼 엘리스** | 오리건 소프트웨어 |
| **배리 헤드퀴스트** | 페레니얼 |
| **사산 하제기** | 페리투스 인터내셔널 |
| **제임스 홈룬드*** | 페리투스 인터내셔널 |
| **토마스 플럼** | 플럼 홀 |
| **크리스토퍼 스켈리*** | 플럼 홀 |
| **앤드류 존슨** | 프라임 컴퓨터 |
| **프랜 리테리오*** | 프라임 컴퓨터 |
| **다니엘 J. 콘래드** | 프리즈매틱스 |
| **데이비드 프리츠** | 프로덕션 랭귀지 |
| **케네스 퓨** | 퓨 킬린 |
| **에드 램지** | 퍼듀 대학교 |
| **스티븐 로버츠*** | 퍼듀 대학교 |
| **케빈 놀란** | 퀀티테이티브 테크놀로지 Corp. |
| **로버트 뮬러*** | 퀀티테이티브 테크놀로지 Corp. |
| **크리스 드보니** | 큐 코퍼레이션 |
| **존 털크** | 래빗 소프트웨어 |
| **테리 콜리건** | 래셔널 시스템즈 |
| **다니엘 삭스** | 삭스 & 어소시에이츠 |
| **낸시 삭스*** | 삭스 & 어소시에이츠 |
| **올리버 브래들리** | SAS 인스티튜트 |
| **앨런 빌*** | SAS 인스티튜트 |
| **래리 존스** | SDRC |
| **도널드 코스만** | SEI 정보 기술 |
| **케네스 해런스틴** | SRI 인터내셔널 |
| **래리 로젠탈** | 시에라 시스템즈 |
| **필 헴프너** | 서던 벨 텔레폰 |
| **퍼쇼탐 라자니** | 스프루스 테크놀로지 |
| **사부 사불레스쿠** | 스택 시스템즈 |
| **피터 다넬** | 스텔라 컴퓨터 |
| **리 W. 쿱라이더*** | 스텔라 컴퓨터 |
| **폴 길마틴** | 스토리지 테크놀로지 Corp. |
| **스티브 머크닉** | 썬 마이크로시스템즈 |
| **척 라스볼드** | 슈퍼컴퓨터 시스템즈 |
| **켈리 오헤어*** | 슈퍼컴퓨터 시스템즈 |
| **헨리 리처드슨** | 탠덤 |
| **존 M. 하우스만*** | 탠덤 |
| **사무엘 하비슨** | 타탄 연구소 |
| **마이클 S. 볼** | 타우메트릭 |
| **칼 서튼** | 텍트로닉스 |
| **짐 베세머*** | 텍트로닉스 |
| **리드 타지** | 텍사스 인스트루먼트 |
| **에드 브로워** | 토크하임 |
| **로버트 맨스필드*** | 토크하임 |
| **모니카 쿠쉬프** | 팀랩스 |
| **모건 존스*** | 팀랩스 |
| **돈 빅슬러** | 유니시스 |
| **스티브 바텔스*** | 유니시스 |
| **글렌다 버크하이머*** | 유니시스 |
| **애니스 잭슨*** | 유니시스 |
| **프레드 블론더** | 메릴랜드 대학교 |
| **프레드 슈워츠** | 미시간 대학교 |
| **R. 조던 크라인들러** | 남부 캘리포니아 대학교 CTC |
| **마이크 카모디** | 워털루 대학교 |
| **더글러스 귄** | 미 육군 BRL *(IEEE P1003 연락책)* |
| **C. 데일 피어스*** | 미 육군 경영 공학 |
| **존 C. 블랙** | 비디오파이낸셜 |
| **조셉 무사키아** | 왕 랩스 |
| **프레드 로자키스*** | 왕 랩스 |
| **P. J. 플로거** | 화이트스미스 |
| **킴 리퍼** | 윅 힐 |
| **마크 위텐버그** | 젠텔 |
| **짐 발터** | |
| **로버트 브래드버리** | |
| **에드워드 친** | |
| **닐 대니얼스** | |
| **스티븐 데소피** | |
| **마이클 더피** | |
| **필립 에스큐** | |
| **랄프 프레이너** | |
| **D. 휴 레델마이어** | |
| **아놀드 다비 로빈스** | |
| **로저 윌크스** | |
| **마이클 J. 영** | |

| | | | |
| :--- | :--- | :--- | :--- |
| **목적** | [1.1](#11-목적) | **적용 범위** | [1.2](#12-적용-범위) |
| **참조 문헌** | [1.3](#13-참고-문헌) | **문서의 구성** | [1.4](#14-문서의-구성) |
| **기초 문서** | [1.5](#15-기초-문서) | **용어의 정의** | [1.6](#16-용어의-정의) |
| **적합성** | [1.7](#17-적합성) | **번역 환경** | [2.](#2-환경) |
| **실행 환경** | [2.](#2-환경) | **분할 컴파일** | [2.1.1.1](#2111-프로그램-구조) |
| **분할 번역** | [2.1.1.1](#2111-프로그램-구조) | **소스 파일** | [2.1.1.1](#2111-프로그램-구조) |
| **번역 단위** | [2.1.1.1](#2111-프로그램-구조) | **프로그램 실행** | [2.1.2.3](#2123-프로그램-실행) |
| **부작용** | [2.1.2.3](#2123-프로그램-실행) | **시퀀스 포인트** | [2.1.2.3](#2123-프로그램-실행) |
| **문자 집합** | [2.2.1](#221-문자-집합) | **신호** | [2.2.3](#223-신호와-인터럽트) |
| **인터럽트** | [2.2.3](#223-신호와-인터럽트) | **구문 표기법** | [3.](#3-언어) |
| **어휘 요소** | [3.1](#31-어휘-요소) | **주석** | [3.1](#31-어휘-요소) |
| **공백** | [3.1](#31-어휘-요소) | **키워드 목록** | [3.1.1](#311-키워드) |
| **예약어** | [3.1.1](#311-키워드) | **밑줄 문자** | [3.1.2](#312-식별자) |
| **열거 상수** | [3.1.2](#312-식별자) | **이름의 길이** | [3.1.2](#312-식별자) |
| **내부 이름, 길이** | [3.1.2](#312-식별자) | **외부 이름, 길이** | [3.1.2](#312-식별자) |
| **함수 이름, 길이** | [3.1.2](#312-식별자) | **유효 범위** | [3.1.2.1](#3121-식별자의-유효-범위) |
| **프로토타입, 함수** | [3.1.2.1](#3121-식별자의-유효-범위) | **함수 유효 범위** | [3.1.2.1](#3121-식별자의-유효-범위) |
| **파일 유효 범위** | [3.1.2.1](#3121-식별자의-유효-범위) | **블록 유효 범위** | [3.1.2.1](#3121-식별자의-유효-범위) |
| **블록 구조** | [3.1.2.1](#3121-식별자의-유효-범위) | **함수 프로토타입 유효 범위** | [3.1.2.1](#3121-식별자의-유효-범위) |
| **연결** | [3.1.2.2](#3122-식별자의-연결) | **외부 연결** | [3.1.2.2](#3122-식별자의-연결) |
| **내부 연결** | [3.1.2.2](#3122-식별자의-연결) | **무연결** | [3.1.2.2](#3122-식별자의-연결) |
| **이름 공간** | [3.1.2.3](#3123-식별자의-이름-공간) | **이름 있는 라벨** | [3.1.2.3](#3123-식별자의-이름-공간) |
| **구조체 태그** | [3.1.2.3](#3123-식별자의-이름-공간) | **공용체 태그** | [3.1.2.3](#3123-식별자의-이름-공간) |
| **열거 타입 태그** | [3.1.2.3](#3123-식별자의-이름-공간) | **구조체 멤버 이름** | [3.1.2.3](#3123-식별자의-이름-공간) |
| **공용체 멤버 이름** | [3.1.2.3](#3123-식별자의-이름-공간) | **기억 수명** | [3.1.2.4](#3124-객체의-저장-기간) |
| **정적 기억 수명** | [3.1.2.4](#3124-객체의-저장-기간) | **자동 기억 수명** | [3.1.2.4](#3124-객체의-저장-기간) |
| **타입** | [3.1.2.5](#3125-타입) | **객체 타입** | [3.1.2.5](#3125-타입) |
| **함수 타입** | [3.1.2.5](#3125-타입) | **불완전 타입** | [3.1.2.5](#3125-타입) |
| **char 타입** | [3.1.2.5](#3125-타입) | **부호 있는 문자** | [3.1.2.5](#3125-타입) |
| **signed char 타입** | [3.1.2.5](#3125-타입) | **short 타입** | [3.1.2.5](#3125-타입) |
| **long 타입** | [3.1.2.5](#3125-타입) | **unsigned 타입** | [3.1.2.5](#3125-타입) |
| **float 타입** | [3.1.2.5](#3125-타입) | **double 타입** | [3.1.2.5](#3125-타입) |
| **long double 타입** | [3.1.2.5](#3125-타입) | **기본 타입** | [3.1.2.5](#3125-타입) |
| **문자 타입** | [3.1.2.5](#3125-타입) | **열거 타입** | [3.1.2.5](#3125-타입) |
| **void 타입** | [3.1.2.5](#3125-타입) | **파생 타입** | [3.1.2.5](#3125-타입) |
| **정수 타입** | [3.1.2.5](#3125-타입) | **산술 타입** | [3.1.2.5](#3125-타입) |
| **스칼라 타입** | [3.1.2.5](#3125-타입) | **집합체 타입** | [3.1.2.5](#3125-타입) |
| **상수** | [3.1.3](#313-상수) | **부동 소수점 상수** | [3.1.3.1](#3131-실수-상수) |
| **double 상수** | [3.1.3.1](#3131-실수-상수) | **정수 상수** | [3.1.3.2](#3132-정수-상수) |
| **10진수 상수** | [3.1.3.2](#3132-정수-상수) | **8진수 상수** | [3.1.3.2](#3132-정수-상수) |
| **16진수 상수** | [3.1.3.2](#3132-정수-상수) | **unsigned 상수** | [3.1.3.2](#3132-정수-상수) |
| **long 상수** | [3.1.3.2](#3132-정수-상수) | **열거 상수** | [3.1.3.3](#3133-열거-상수) |
| **문자 상수** | [3.1.3.4](#3134-문자-상수) | **백슬래시 문자** | [3.1.3.4](#3134-문자-상수) |
| **이스케이프 문자** | [3.1.3.4](#3134-문자-상수) | **이스케이프 시퀀스** | [3.1.3.4](#3134-문자-상수) |
| **문자열 리터럴** | [3.1.4](#314-문자열-리터럴) | **문자열** | [3.1.4](#314-문자열-리터럴) |
| **연산자** | [3.1.5](#315-연산자) | **평가** | [3.1.5](#315-연산자) |
| **피연산자** | [3.1.5](#315-연산자) | **구두점** | [3.1.6](#316-구두점) |
| **문자-정수 변환** | [3.2.1.1](#3211-문자와-정수) | **정수-문자 변환** | [3.2.1.1](#3211-문자와-정수) |
| **정수 승격** | [3.2.1.1](#3211-문자와-정수) | **정수-long 변환** | [3.2.1.1](#3211-문자와-정수) |
| **부호 있는 문자** | [3.2.1.1](#3211-문자와-정수) | **unsigned-정수 변환** | [3.2.1.2](#3212-부호-있는-정수와-부호-없는-정수) |
| **정수-unsigned 변환** | [3.2.1.2](#3212-부호-있는-정수와-부호-없는-정수) | **long-unsigned 변환** | [3.2.1.2](#3212-부호-있는-정수와-부호-없는-정수) |
| **long-정수 변환** | [3.2.1.2](#3212-부호-있는-정수와-부호-없는-정수) | **부동 소수점-정수 변환** | [3.2.1.3](#3213-실수과-정수) |
| **정수-부동 소수점 변환** | [3.2.1.3](#3213-실수과-정수) | **float-double 변환** | [3.2.1.4](#3214-실수-타입) |
| **double-float 변환** | [3.2.1.4](#3214-실수-타입) | **산술 변환** | [3.2.1.5](#3215-일반-산술-변환) |
| **타입 변환 규칙** | [3.2.1.5](#3215-일반-산술-변환) | **Lvalue** | [3.2.2.1](#3221-lvalue와-함수-지정자) |
| **함수 지정자** | [3.2.2.1](#3221-lvalue와-함수-지정자) | **배열의 변환** | [3.2.2.1](#3221-lvalue와-함수-지정자) |
| **함수 이름의 변환** | [3.2.2.1](#3221-lvalue와-함수-지정자) | **void 타입** | [3.2.2.2](#3222-void) |
| **포인터-포인터 변환** | [3.2.2.3](#3223-포인터) | **정수-포인터 변환** | [3.2.2.3](#3223-포인터) |
| **null 포인터** | [3.2.2.3](#3223-포인터) | **수식** | [3.3](#33-수식) |
| **연산자 우선순위** | [3.3](#33-수식) | **연산자 결합 법칙** | [3.3](#33-수식) |
| **수식 평가 순서** | [3.3](#33-수식) | **평가 순서** | [3.3](#33-수식) |
| **비트 연산자** | [3.3](#33-수식) | **예외** | [3.3](#33-수식) |
| **기본 수식** | [3.3.1](#331-기본-수식) | **문자열의 타입** | [3.3.1](#331-기본-수식) |
| **괄호 수식** | [3.3.1](#331-기본-수식) | **첨자 연산자** | [3.3.2](#332-후위-연산자) |
| **함수 호출** | [3.3.2](#332-후위-연산자) | **구조체 멤버 연산자** | [3.3.2](#332-후위-연산자) |
| **구조체 포인터 연산자** | [3.3.2](#332-후위-연산자) | **++ 증가 연산자** | [3.3.2](#332-후위-연산자) |
| **-- 감소 연산자** | [3.3.2](#332-후위-연산자) | **배열, 첨자 연산 설명** | [3.3.2.1](#3321-배열-첨자) |
| **첨자 연산, 설명** | [3.3.2.1](#3321-배열-첨자) | **다차원 배열** | [3.3.2.1](#3321-배열-첨자) |
| **배열의 저장 순서** | [3.3.2.1](#3321-배열-첨자) | **함수 호출** | [3.3.2.2](#3322-함수-호출) |
| **함수의 암묵적 선언** | [3.3.2.2](#3322-함수-호출) | **함수 인자** | [3.3.2.2](#3322-함수-호출) |
| **값에 의한 호출** | [3.3.2.2](#3322-함수-호출) | **재귀** | [3.3.2.2](#3322-함수-호출) |
| **구조체 참조** | [3.3.2.3](#3323-구조체-및-공용체-멤버) | **공용체 참조** | [3.3.2.3](#3323-구조체-및-공용체-멤버) |
| **공통 초기 시퀀스** | [3.3.2.3](#3323-구조체-및-공용체-멤버) | **후위 ++ 및 --** | [3.3.2.4](#3324-후위-증감-연산자) |
| **-- 감소 연산자** | [3.3.2.4](#3324-후위-증감-연산자) | **단항 수식** | [3.3.3](#333-단항-연산자) |
| **++ 증가 연산자** | [3.3.3](#333-단항-연산자) | **-- 감소 연산자** | [3.3.3](#333-단항-연산자) |
| **sizeof 연산자** | [3.3.3](#333-단항-연산자) | **& 주소 연산자** | [3.3.3](#333-단항-연산자) |
| *** 간접 참조 연산자** | [3.3.3](#333-단항-연산자) | **+ 단항 플러스 연산자** | [3.3.3](#333-단항-연산자) |
| **- 단항 마이너스 연산자** | [3.3.3](#333-단항-연산자) | **~ 비트 보수 연산자** | [3.3.3](#333-단항-연산자) |
| **! 논리 부정 연산자** | [3.3.3](#333-단항-연산자) | **++ 증가 연산자** | [3.3.3.1](#3331-전위-증감-연산자) |
| **전위 ++ 및 --** | [3.3.3.1](#3331-전위-증감-연산자) | **-- 감소 연산자** | [3.3.3.1](#3331-전위-증감-연산자) |
| **+ 단항 플러스 연산자** | [3.3.3.3](#3333-단항-산술-연산자) | **- 단항 마이너스 연산자** | [3.3.3.3](#3333-단항-산술-연산자) |
| **~ 비트 보수 연산자** | [3.3.3.3](#3333-단항-산술-연산자) | **! 논리 부정 연산자** | [3.3.3.3](#3333-단항-산술-연산자) |
| **바이트** | [3.3.3.4](#3334-sizeof-연산자) | **기억 장치 할당자** | [3.3.3.4](#3334-sizeof-연산자) |
| **캐스트 수식** | [3.3.4](#334-타입-변환-연산자) | **캐스트 연산자** | [3.3.4](#334-타입-변환-연산자) |
| **명시적 변환 연산자** | [3.3.4](#334-타입-변환-연산자) | **포인터 변환** | [3.3.4](#334-타입-변환-연산자) |
| **명시적 변환 연산자** | [3.3.4](#334-타입-변환-연산자) | **포인터-정수 변환** | [3.3.4](#334-타입-변환-연산자) |
| **정수-포인터 변환** | [3.3.4](#334-타입-변환-연산자) | **정렬 제한** | [3.3.4](#334-타입-변환-연산자) |
| **산술 연산자** | [3.3.5](#335-곱셈-연산자) | **승제 연산자** | [3.3.5](#335-곱셈-연산자) |
| *** 곱셈 연산자** | [3.3.5](#335-곱셈-연산자) | **/ 나눗셈 연산자** | [3.3.5](#335-곱셈-연산자) |
| **% 나머지 연산자** | [3.3.5](#335-곱셈-연산자) | **가감 연산자** | [3.3.6](#336-덧셈-연산자) |
| **+ 덧셈 연산자** | [3.3.6](#336-덧셈-연산자) | **- 뺄셈 연산자** | [3.3.6](#336-덧셈-연산자) |
| **포인터 산술** | [3.3.6](#336-덧셈-연산자) | **시프트 연산자** | [3.3.7](#337-비트-시프트-연산자) |
| **<< 왼쪽 시프트 연산자** | [3.3.7](#337-비트-시프트-연산자) | **>> 오른쪽 시프트 연산자** | [3.3.7](#337-비트-시프트-연산자) |
| **관계 연산자** | [3.3.8](#338-관계-연산자) | **< 작다 연산자** | [3.3.8](#338-관계-연산자) |
| **> 크다 연산자** | [3.3.8](#338-관계-연산자) | **<= 작거나 같다 연산자** | [3.3.8](#338-관계-연산자) |
| **>= 크거나 같다 연산자** | [3.3.8](#338-관계-연산자) | **포인터 비교** | [3.3.8](#338-관계-연산자) |
| **등가 연산자** | [3.3.9](#339-등가-연산자) | **== 동등 연산자** | [3.3.9](#339-등가-연산자) |
| **!= 부등 연산자** | [3.3.9](#339-등가-연산자) | **& 비트 AND 연산자** | [3.3.10](#3310-비트-and-연산자) |
| **^ 비트 배타적 OR 연산자** | [3.3.11](#3311-비트-배타적-or-연산자) | **\| 비트 포괄적 OR 연산자** | [3.3.12](#3312-비트-포과적-or-연산자) |
| **&& 논리 AND 연산자** | [3.3.13](#3313-논리-and-연산자) | **\|\| 논리 OR 연산자** | [3.3.14](#3314-논리-or-연산자) |
| **?: 조건 수식** | [3.3.15](#3315-조건-연산자) | **대입 연산자** | [3.3.16](#3316-대입-연산자) |
| **대입 수식** | [3.3.16](#3316-대입-연산자) | **단순 대입** | [3.3.16.1](#33161-단순-대입) |
| **대입에 의한 변환** | [3.3.16.1](#33161-단순-대입) | **복합 대입** | [3.3.16.2](#33162-복합-대입) |
| **쉼표 연산자** | [3.3.17](#3317-쉼표-연산자) | **상수 수식** | [3.4](#34-상수-수식) |
| **허용된 초기화 형식** | [3.4](#34-상수-수식) | **선언** | [3.5](#35-선언) |
| **기억 부류 지정자** | [3.5.1](#351-저장-종류-지정자) | **기억 부류 선언** | [3.5.1](#351-저장-종류-지정자) |
| **typedef 선언** | [3.5.1](#351-저장-종류-지정자) | **extern 기억 부류** | [3.5.1](#351-저장-종류-지정자) |
| **static 기억 부류** | [3.5.1](#351-저장-종류-지정자) | **auto 기억 부류** | [3.5.1](#351-저장-종류-지정자) |
| **register 기억 부류** | [3.5.1](#351-저장-종류-지정자) | **타입 지정자** | [3.5.2](#352-타입-지정자) |
| **void 타입** | [3.5.2](#352-타입-지정자) | **char 타입** | [3.5.2](#352-타입-지정자) |
| **short 타입** | [3.5.2](#352-타입-지정자) | **int 타입** | [3.5.2](#352-타입-지정자) |
| **long 타입** | [3.5.2](#352-타입-지정자) | **float 타입** | [3.5.2](#352-타입-지정자) |
| **double 타입** | [3.5.2](#352-타입-지정자) | **signed 타입** | [3.5.2](#352-타입-지정자) |
| **unsigned 타입** | [3.5.2](#352-타입-지정자) | **구조체 선언** | [3.5.2.1](#3521-구조체-및-공용체-지정자) |
| **공용체 선언** | [3.5.2.1](#3521-구조체-및-공용체-지정자) | **비트 필드 선언** | [3.5.2.1](#3521-구조체-및-공용체-지정자) |
| **비트 필드** | [3.5.2.1](#3521-구조체-및-공용체-지정자) | **멤버 정렬** | [3.5.2.1](#3521-구조체-및-공용체-지정자) |
| **열거체** | [3.5.2.2](#3522-열거체-지정자) | **enum 지정자** | [3.5.2.2](#3522-열거체-지정자) |
| **열거자** | [3.5.2.2](#3522-열거체-지정자) | **구조체 태그** | [3.5.2.3](#3523-태그) |
| **공용체 태그** | [3.5.2.3](#3523-태그) | **구조체 내용** | [3.5.2.3](#3523-태그) |
| **공용체 내용** | [3.5.2.3](#3523-태그) | **열거 타입 내용** | [3.5.2.3](#3523-태그) |
| **자기 참조 구조체** | [3.5.2.3](#3523-태그) | **타입 한정자** | [3.5.3](#353-타입-한정자) |
| **const 타입 한정자** | [3.5.3](#353-타입-한정자) | **volatile 타입 한정자** | [3.5.3](#353-타입-한정자) |
| **선언자** | [3.5.4](#354-선언자) | **타입 선언** | [3.5.4](#354-선언자) |
| **포인터 선언** | [3.5.4.1](#3541-포인터-선언자) | **배열 선언** | [3.5.4.2](#3542-배열-선언자) |
| **함수 선언** | [3.5.4.3](#3543-함수-선언자프로토타입-포함) | **타입 이름** | [3.5.5](#355-타입-이름) |
| **추상 선언자** | [3.5.5](#355-타입-이름) | **typedef 선언** | [3.5.6](#356-타입-정의) |
| **초기화** | [3.5.7](#357-초기화) | **정적 객체 초기화** | [3.5.7](#357-초기화) |
| **암묵적 초기화** | [3.5.7](#357-초기화) | **기본 초기화** | [3.5.7](#357-초기화) |
| **자동 객체 초기화** | [3.5.7](#357-초기화) | **집합체 초기화** | [3.5.7](#357-초기화) |
| **배열 초기화** | [3.5.7](#357-초기화) | **구조체 초기화** | [3.5.7](#357-초기화) |
| **문자 배열 초기화** | [3.5.7](#357-초기화) | **wchar_t 배열 초기화** | [3.5.7](#357-초기화) |
| **문장** | [3.6](#36-문장) | **문장의 순서** | [3.6](#36-문장) |
| **완전 수식** | [3.6](#36-문장) | **라벨이 붙은 문장** | [3.6.1](#361-라벨이-붙은-문장) |
| **이름 있는 라벨** | [3.6.1](#361-라벨이-붙은-문장) | **case 라벨** | [3.6.1](#361-라벨이-붙은-문장) |
| **default 라벨** | [3.6.1](#361-라벨이-붙은-문장) | **복합문** | [3.6.2](#362-복합문-또는-블록) |
| **블록** | [3.6.2](#362-복합문-또는-블록) | **블록 구조** | [3.6.2](#362-복합문-또는-블록) |
| **블록 내 초기화** | [3.6.2](#362-복합문-또는-블록) | **수식문** | [3.6.3](#363-수식문과-null-문) |
| **null 문** | [3.6.3](#363-수식문과-null-문) | **빈 문** | [3.6.3](#363-수식문과-null-문) |
| **if-else 문** | [3.6.4.1](#3641-if-문) | **switch 문** | [3.6.4.2](#3642-switch-문) |
| **switch 본체** | [3.6.4.2](#3642-switch-문) | **루프 본체** | [3.6.5](#365-반복문) |
| **while 문** | [3.6.5.1](#3651-while-문) | **do 문** | [3.6.5.2](#3652-do-문) |
| **for 문** | [3.6.5.3](#3653-for-문) | **goto 문** | [3.6.6.1](#3661-goto-문) |
| **continue 문** | [3.6.6.2](#3662-continue-문) | **break 문** | [3.6.6.3](#3663-break-문) |
| **return 문** | [3.6.6.4](#3664-return-문) | **return에 의한 타입 변환** | [3.6.6.4](#3664-return-문) |
| **return에 의한 변환** | [3.6.6.4](#3664-return-문) | **외부 정의** | [3.7](#37-외부-정의) |
| **함수 정의** | [3.7.1](#371-함수-정의) | **매개변수** | [3.7.1](#371-함수-정의) |
| **배열 인자** | [3.7.1](#371-함수-정의) | **함수 이름 인자** | [3.7.1](#371-함수-정의) |
| **함수 포인터** | [3.7.1](#371-함수-정의) | **객체 정의** | [3.7.2](#372-외부-객체-정의) |
| **외부 객체의 유효 범위** | [3.7.2](#372-외부-객체-정의) | **잠정적 정의** | [3.7.2](#372-외부-객체-정의) |
| **전처리 지시문** | [3.8](#38-전처리-지시문) | **매크로 전처리기** | [3.8](#38-전처리-지시문) |
| **전처리 지시문 라인** | [3.8](#38-전처리-지시문) | **조건부 포함** | [3.8.1](#381-조건부-포함) |
| **#if** | [3.8.1](#381-조건부-포함) | **#elif** | [3.8.1](#381-조건부-포함) |
| **#ifdef** | [3.8.1](#381-조건부-포함) | **#ifndef** | [3.8.1](#381-조건부-포함) |
| **#else** | [3.8.1](#381-조건부-포함) | **#endif** | [3.8.1](#381-조건부-포함) |
| **#include** | [3.8.2](#382-소스-파일-포함) | **소스 파일 포함** | [3.8.2](#382-소스-파일-포함) |
| **매크로 치환** | [3.8.3](#383-매크로-치환) | **객체형 매크로** | [3.8.3](#383-매크로-치환) |
| **함수형 매크로** | [3.8.3](#383-매크로-치환) | **매크로 이름** | [3.8.3](#383-매크로-치환) |
| **#define** | [3.8.3](#383-매크로-치환) | **매크로 매개변수** | [3.8.3](#383-매크로-치환) |
| **매크로 호출** | [3.8.3](#383-매크로-치환) | **인자 치환** | [3.8.3.1](#3831-인자-치환) |
| **# 연산자** | [3.8.3.2](#3832--연산자) | **## 연산자** | [3.8.3.3](#3833--연산자) |
| **재검색 및 치환** | [3.8.3.4](#3834-재스캔-및-추가-치환) | **매크로 정의 유효 범위** | [3.8.3.5](#3835-매크로-정의의-범위) |
| **#undef** | [3.8.3.5](#3835-매크로-정의의-범위) | **#line** | [3.8.4](#384-줄-제어) |
| **에러 지시문** | [3.8.5](#385-에러-지시문) | **pragma 지시문** | [3.8.6](#386-pragma-지시문) |
| **null 지시문** | [3.8.7](#387-null-지시문) | **개요** | [4.1](#41-개요) |
| **문자열 정의** | [4.1.1](#411-용어의-정의) | **문자 정의** | [4.1.1](#411-용어의-정의) |
| **소수점 정의** | [4.1.1](#411-용어의-정의) | **예약된 식별자** | [4.1.2](#412-표준-헤더) |
| **인쇄 가능 문자** | [4.3](#43-문자-처리-ctypeh) | **제어 문자** | [4.3](#43-문자-처리-ctypeh) |
| **가변 인자** | [4.8](#48-가변-인자variable-arguments-stdargh) | **버퍼 없는 스트림** | [4.9.3](#493-파일) |
| **완전 버퍼링 스트림** | [4.9.3](#493-파일) | **라인 버퍼링 스트림** | [4.9.3](#493-파일) |
| **부록** | [A.](#a-부록) | **언어 구문 요약** | [A.1](#a1-언어-구문-요약) |
| **시퀀스 포인트** | [A.2](#a2-시퀀스-포인트) | **라이브러리 요약** | [A.3](#a3-라이브러리-요약) |
| **구현 한계** | [A.4](#a4-구현-한계) | **공통 경고** | [A.5](#a5-공통-경고) |
| **이식성 문제** | [A.6](#a6-이식성-문제) | **평가 순서** | [A.6.1](#a61-미지정-동작) |
| **기계 의존성** | [A.6.3](#a63-구현-정의-동작) | **레지스터 제약** | [A.6.3.7](#a637-레지스터) |
| **함수 포인터 타입 변환** | [A.6.5.7](#a657-함수-포인터-타입-변환) | **비트 필드 타입** | [A.6.5.8](#a658-int가-아닌-비트-필드-타입) |
| **fortran 키워드** | [A.6.5.9](#a659-fortran-키워드) | **asm 키워드** | [A.6.5.10](#a6510-asm-키워드) |
| **다중 외부 정의** | [A.6.5.11](#a6511-다중-외부-정의) | **빈 매크로 인자** | [A.6.5.12](#a6512-빈-매크로-인자) |
| **미리 정의된 매크로 이름** | [A.6.5.13](#a6513-미리-정의된-매크로-이름) | **신호 처리기 인자** | [A.6.5.14](#a6514-신호-처리기에-대한-추가-인자) |
| **스트림 유형** | [A.6.5.15](#a6515-추가-스트림-유형-및-파일-열기-모드) | **파일 열기 모드** | [A.6.5.15](#a6515-추가-스트림-유형-및-파일-열기-모드) |
| **파일 위치 표시자** | [A.6.5.16](#a6516-정의된-파일-위치-표시자) | **색인** | [A.7](#a7-색인) |

## 1. 서론

### 1.1 목적

이 표준은 C 프로그래밍 언어로 작성된 프로그램의 형식을 규정하고, 그 프로그램에 대한 해석을 확립한다. [^1]

### 1.2 적용 범위

이 표준은 다음을 규정한다:

* C 프로그램의 표현;

* C 언어의 구문과 제약;

* C 프로그램을 해석하기 위한 의미 규칙;

* C 프로그램이 처리할 입력 데이터의 표현;

* C 프로그램이 생성하는 출력 데이터의 표현;

* C의 적합 구현에 의해 부과되는 제한 사항과 한계.

이 표준은 다음을 규정하지 않는다:

* 데이터 처리 시스템에서 사용하기 위해 C 프로그램을 변환하는 메커니즘;

* 데이터 처리 시스템에서 사용하기 위해 C 프로그램을 실행하는 메커니즘;

* C 프로그램에서 사용하기 위해 입력 데이터를 변환하는 메커니즘;

* C 프로그램이 출력 데이터를 생성한 후 그 출력 데이터를 변환하는 메커니즘;

* 특정 데이터 처리 시스템의 용량 또는 특정 프로세서의 용량을 초과하게 될 프로그램 및 그 데이터의 크기나 복잡도;

* 적합 구현을 지원할 수 있는 데이터 처리 시스템이 갖추어야 할 모든 최소 요구사항.

### 1.3 참고 문헌

1. 데니스 M. 리치(Dennis M. Ritchie)의 “The C Reference Manual”. 이 문서의 한 버전은 브라이언 W. 커니핸(Brian W. Kernighan)과 데니스 M. 리치의 The C Programming Language (Prentice-Hall, Inc., 1978)로 출판되었다. 저작권은 AT&T가 보유한다.

2. /usr/group 표준 위원회(미국 캘리포니아주 산타클라라)가 제정한 1984 /usr/group 표준(1984년 11월).

3. 정보 처리 시스템용 미국 국가 사전, 정보 처리 시스템 기술 보고서 ANSI X3/TR-1-82(1982).

4. ISO 646-1983 불변 코드 집합.

5. 이진 부동소수점 산술에 관한 IEEE 표준 (ANSI/IEEE Std 754-1985).

6. 통화 및 자금 표시를 위한 코드 ISO 4217.

### 1.4 문서의 구성

이 문서는 다음의 네 개 주요 부분으로 나뉜다:

1. 이 서론;

2. C 프로그램을 번역하고 실행하는 환경의 특성;

3. 언어의 구문, 제약, 및 의미;

4. 라이브러리 기능.

기술된 구성 요소의 가능한 형태를 보여 주기 위해 예제가 제공된다. 각주는 해당 절 또는 표준의 다른 곳에서 기술된 규칙의 결과를 강조하기 위해 제공된다. 참조는 다른 관련 절을 가리키는 데 사용된다. 일련의 부록은 표준에 포함된 정보를 요약한다. 초록, 머리말, 예제, 각주, 참고문헌, 부록은 표준의 일부가 아니다.

### 1.5 기초 문서

언어 절([3.](#3-언어))은 데니스 M. 리치(Dennis M. Ritchie)의 "The C Reference Manual"에서 유래한 것으로, 그 한 버전은 브라이언 W. 커니핸과 데니스 M. 리치의 The C Programming Language (Prentice-Hall, Inc., 1978)의 부록 A로 출판되었다. 저작권은 AT&T가 소유한다.

라이브러리 절([4.](#4-라이브러리))은 /usr/group 표준위원회(미국 캘리포니아주 산타클라라, USA)의 1984 /usr/group 표준(1984년 11월 14일)에 기반한다.

### 1.6 용어의 정의

이 표준에서 "shall"은 구현 또는 프로그램에 대한 요구 사항으로 해석하며, 반대로 "shall not"은 금지로 해석한다.

이 문서에서 다음 용어를 사용한다:

* 구현 — 특정 번역 환경에서 특정 제어 옵션 하에 실행되는 특정 소프트웨어 집합으로서, 특정 실행 환경을 대상으로 프로그램의 번역을 수행하고, 그 실행 환경에서 함수의 실행을 지원하는 것.

* 비트 — 실행 환경에서, 두 값 중 하나를 가질 수 있는 객체를 저장하기에 충분히 큰 데이터 저장 단위. 객체의 각 개별 비트 주소를 표현할 수 있을 필요는 없다.

* 바이트 — 실행 환경에서, 실행 환경의 기본 문자 집합의 어떤 구성원도 담을 수 있을 만큼 충분히 큰 데이터 저장 단위. 객체의 각 개별 바이트 주소는 유일하게 표현할 수 있어야 한다. 바이트는 연속된 비트들의 연속으로 구성되며, 그 비트 수는 구현에서 정한다. 가장 작은 자리수 비트를 하위 비트, 가장 큰 자리수 비트를 상위 비트라 한다.

* 객체 — 실행 환경에서 값들을 표현할 수 있는 내용물을 가지는 데이터 저장 영역. 비트 필드를 제외하면, 객체는 하나 이상의 바이트로 이루어진 연속된 바이트들의 연속으로 구성되며, 그 바이트들의 개수, 순서, 부호화는 명시적으로 규정되거나 구현 정의이다.

* 문자 — 소스 환경 또는 실행 환경의 기본 문자 집합의 구성원을 나타내는 단일 바이트.

* 멀티 바이트 문자 — 소스 환경 또는 실행 환경의 확장 문자 집합의 구성원을 나타내는 하나 이상의 바이트로 이루어진 바이트 열. 확장 문자 집합은 기본 문자 집합을 포함한다.

* 정렬 — 특정 타입의 객체가, 바이트 주소의 특정 배수에 해당하는 주소를 갖는 저장 경계에 위치해야 한다는 요구 사항.

* 인자 — 함수 호출 식에서 괄호로 둘러싸인 쉼표로 구분된 목록에 있는 수식, 또는 함수형 매크로 호출에서 괄호로 둘러싸인 쉼표로 구분된 목록 안에 있는 전처리 토큰들의 나열. "실질 인자" 또는 "실질 매개변수"라고도 한다.

* 매개변수 — 함수 선언 또는 정의의 일부로 선언되어 함수 진입 시 값을 갖게 되는 객체, 또는 함수형 매크로 정의에서 매크로 이름 바로 뒤의 괄호로 둘러싸인 쉼표로 구분된 목록에 있는 식별자. "형식 인자" 또는 "형식 매개변수"라고도 한다.

* 미지정 동작 — 올바른 프로그램 구성과 올바른 데이터에 대해, 이 표준이 아무 요구 사항도 부과하지 않는 동작.

* 정의되지 않은 동작 — 비이식적이거나 오류인 프로그램 구성, 오류인 데이터, 또는 값이 불확정인 객체의 사용으로 인해 발생하는 동작으로서, 이 표준이 아무 요구 사항도 부과하지 않는 동작. 허용되는 정의되지 않은 동작은, 예측 불가능한 결과를 낳더라도 그 상황을 완전히 무시하는 것부터, 번역 중 또는 프로그램 실행 중 환경 특유의 문서화된 방식으로 동작하는 것(진단 메시지를 출력할 수도 있고 출력하지 않을 수도 있다), 또는 번역이나 실행을 종료하는 것(진단 메시지를 출력하면서)까지 다양할 수 있다.

제약 밖에서 나타나는 "shall" 또는 "shall not" 요구 사항이 위반되면, 그 동작은 정의되지 않는다. 이 밖에도 정의되지 않은 동작은 이 표준에서 "undefined behavior"라는 말로, 또는 동작에 대한 명시적 정의를 생략함으로써 표시된다. 이 셋 사이에는 강조의 차이가 없으며, 모두 "정의되지 않은 동작"을 뜻한다.

* 구현 정의 동작 — 올바른 프로그램 구성과 올바른 데이터에 대해 구현의 특성에 따라 달라지는 동작으로서, 각 구현이 반드시 문서화해야 하는 것.

* 국가 특유 동작 — 국적, 문화, 언어의 지역적 관례에 의존하는 동작으로서, 각 구현이 반드시 문서화해야 하는 것.

* 진단 메시지 — 구현의 메시지 출력 중 구현 정의된 부분집합에 속하는 메시지.

* 제약 — 언어 요소에 대한 기술이 해석되어야 하는 구문적 및 의미적 제한.

* 구현 한계 — 구현이 프로그램에 부과하는 제한.

* 전방 참조 — 이 절과 관련된 추가 정보가 들어 있는 표준의 뒤쪽 절에 대한 참조.

그 밖의 용어는 처음 등장하는 곳에서, 이탤릭체로 표시하여 정의한다. 이 표준에서 명시적으로 정의된 용어는, 다른 곳에서 정의된 유사 용어를 암묵적으로 가리킨다고 추정해서는 안 된다.

이 표준에서 정의되지 않은 용어는 정보 처리 시스템용 미국 국가 사전, 정보 처리 시스템 기술 보고서 ANSI X3/TR-1-82 (1982)에 따라 해석한다.

전방 참조: 국제화 ([4.4](#44-국제화-localeh)).

"예시"

미지정 동작의 예: 함수에 전달되는 인자들이 평가되는 순서.

정의되지 않은 동작의 예: 정수 오버플로가 발생했을 때의 동작.

구현 정의 동작의 예: 부호 있는 정수를 오른쪽으로 시프트할 때 상위 비트가 전파되는 방식.

로캘 특유 동작의 예: `islower` 함수가 영어 소문자 26자 이외의 문자에 대해서도 참을 반환하는지 여부.

**전방 참조**: 비트 시프트 연산자 ([3.3.7](#337-비트-시프트-연산자)), 식 ([3.3](#33-수식)), 함수 호출 ([3.3.2.2](#3322-함수-호출)), `islower` 함수 ([4.3.1.6](#4316-islower-함수)).

### 1.7 적합성

엄격하게 적합한 프로그램은 이 표준에 명시된 언어 및 라이브러리의 기능만을 사용해야 한다. 이러한 프로그램은 미지정, 미정의, 또는 구현 정의 동작에 의존하는 출력을 생성해서는 안 되며, 어떠한 최소 구현 한계도 초과해서는 안 된다.

적합한 구현에는 호스트와 프리스탠딩이라는 두 형태가 있다. 적합 호스트 구현은 모든 엄격히 적합한 프로그램을 수용해야 한다. 적합 프리스탠딩 구현은 라이브러리 절([4.](#4-라이브러리))에서 규정한 기능의 사용이 표준 헤더 `<float.h>`, `<limits.h>`, `<stdarg.h>`, `<stddef.h>`의 내용으로 국한된 모든 엄격하게 적합한 프로그램을 수용해야 한다. 적합한 구현은 어떤 엄격하게 적합한 프로그램의 동작도 변경하지 않는다는 조건 하에 확장 기능(추가 라이브러리 함수 포함)을 가질 수 있다.

적합한 프로그램이란 적합한 구현에 의해 받아들여지는 프로그램을 말한다. [^2]

구현에는 모든 구현 정의 특성과 모든 확장을 정의하는 문서가 동반되어야 한다.

**전방 참조(Forward references)**: 한계값 `<float.h>` 및 `<limits.h>` ([4.1.4](#414-한계값-floath-및-limitsh)), 가변 인자 `<stdarg.h>` ([4.8](#48-가변-인자variable-arguments-stdargh)), 공통 정의 `<stddef.h>` ([4.1.5](#415-공통-정의-stddefh)).

### 1.8 향후 방향

새로운 장치와 확장 문자 집합이 도입됨에 따라, 표준에 새로운 기능이 추가될 수 있다. 언어 및 라이브러리 절의 하위 절에서는 구현자와 프로그래머에게, 그 자체로는 유효하지만 향후 추가될 기능과 충돌할 수 있는 사용법에 대해 경고한다.

일부 기능들은 폐기 예정인데, 이는 표준의 향후 개정판에서 삭제 대상으로 고려될 수 있음을 의미한다. 폐기 예정 기능들은 널리 사용되고 있기 때문에 표준에 유지되고는 있으나, 새로운 구현(구현 기능의 경우)이나 새로운 프로그램(언어 및 라이브러리 기능의 경우)에서 사용하는 것은 권장하지 않는다.

**전방 참조**: 향후 언어 방향 ([3.9.9](#39-향후-언어-방향)), 향후 라이브러리 방향 ([4.13](#413-향후-라이브러리-방향)).

### 1.9 이 초안에 대하여

오른쪽 여백에 있는 기호들은 이 초안과 그 이전 버전(ANSI X3J11/88-001, 1988년 1월 11일) 사이의 실질적인 차이점을 표시한다. 더하기 기호(+)는 추가를, 빼기 기호(-)는 삭제를, 막대 기호(|)는 대체를 나타낸다.

이 절과 차이점 표시 기호는 최종 발행 문서에는 포함되지 않을 것이다.

## 2. 환경

구현은 C 소스파일을 번역하고 C 프로그램을 실행하는 것을 두가지 정보 처리 시스템 환경에서 하는데, 본 표준에서는 이들을 번역 환경과 실행 환경이라고 부른다. 이 환경들의 특성은 적합한 C 프로그램의 실행 결과를 적합 구현의 구문 및 의미 규칙에 따라 정의하고 제약한다. 

**전방 참조**: 환경 절([2.](#2-환경))에서는 많은 전방 참조들 가운데 일부만 표시해 두었다.

### 2.1 개념 모델

#### 2.1.1 번역 환경

##### 2.1.1.1 프로그램 구조

C 프로그램의 모든 부분이 반드시 동시에 번역될 필요는 없다. 프로그램의 텍스트는 본 표준에서 소스 파일이라 불리는 단위로 보관된다. 하나의 소스 파일에, 전처리 지시문 `#include`를 통해 포함된 모든 헤더 및 소스 파일을 합치고, 조건부 포함 전처리 지시문에 의해 건너뛴 소스 라인을 제외한 결과를, 번역 단위라고 한다. 먼저 번역된 번역 단위들은 개별적으로 보관되거나 라이브러리 형태로 보관될 수 있다. 같은 프로그램 안의 각 번역 단위들은 서로 상호작용할 때, (예를 들어) 식별자가 외부 연결된 함수를 호출하거나, 식별자가 외부 연결된 객체를 조작하거나, 데이터 파일을 조작한다. 번역 단위들은 개별적으로 번역된 후, 나중에 링크되어 실행 가능한 프로그램을 만들 수 있다.

**전방 참조**: 조건부 포함 ([3.8.1](#381-조건부-포함)), 식별자의 연결 ([3.1.2.2](#3122-식별자의-연결)), 소스 파일 포함 ([3.8.2](#382-소스-파일-포함)).

##### 2.1.1.2 번역 단계
번역의 구문 규칙 간 우선순위는 다음 단계들로 규정된다. [^3]

1. 물리적 소스 파일 문자들은 소스 문자 집합으로 매핑된다(필요한 경우 줄의 끝을 표시하기 위해 개행 문자를 추가한다). 삼중 문자 시퀀스는 그에 해당하는 단일 문자의 내부 표현으로 대체된다.

2. 역슬래시 바로 다음에 오는 개행 문자를 같이 통째로 삭제해서, 물리적 소스 줄들을 이어 붙여 논리적 소스 줄을 형성한다. 비어 있지 않은 소스 파일은 반드시 개행 문자로 끝나야 하며, 그 개행 문자 바로 앞에는 역슬래시 문자가 오면 안된다.

3. 소스 파일은 전처리 토큰과[^4] 공백 문자 시퀀스(주석을 포함한)으로 분해된다. 소스 파일은 불완전한 전처리 토큰이나 주석으로 끝나서는 안된다. 각 주석은 하나의 공백 문자로 대체된다. 개행 문자는 유지된다. 다른 비어 있지 않은 공백 문자 시퀀스를 유지할지, 아니면 하나의 공백 문자로 대체할지는 구현 정의를 따른다.

4. 전처리 지시문이 실행되고 매크로 호출이 확장된다. `#include` 전처리 지시문은 지정된 헤더나 소스 파일이 1단계부터 4단계까지 처리되도록 하며, 이는 재귀적으로 적용된다.

5. 문자 상수와 문자열 리터럴 안에 있는 각 이스케이프 시퀀스는 실행 문자 집합의 멤버로 변환한다.

6. 인접한 문자열 리터럴 토큰들을 하나로 이어붙이고, 인접한 와이드 문자열 리터럴 토큰들도 하나로 이어붙인다.

7. 토큰을 구분하는 공백 문자는 더 이상 의미가 없다. 전처리 토큰은 토큰으로 변환된다. 변환된 토큰들은 구문적 및 의미적으로 분석되고 번역된다.

8. 모든 외부 객체 및 함수 참조가 해결된다. 라이브러리 구성 요소가 현재 번역에서 정의되지 않은 함수 및 객체에 대한 외부 참조를 충족하기 위해 링크된다. 모든 번역기 출력를 모아서 실행 환경에서의 실행에 필요한 정보를 포함하는 프로그램 이미지가 만들어 진다.

**전방 참조**: 어휘 요소 ([3.1](#31-어휘-요소)), 전처리 지시문 ([3.8](#38-전처리-지시문)), 삼중 문자 시퀀스 ([2.2.1.1 삼중 문자 시퀀스](#2211-삼중-문자-시퀀스)).

##### 2.1.1.3 진단

적합한 구현은 구문 규칙이나 제약 사항을 위반한 각 번역 단위에 대해, 적어도 하나의 진단 메시지(구현 정의 방식으로 구분되는)을 생성해야 한다. 그 밖의 경우에는 진단 메시지를 생성할 필요가 없다.

#### 2.1.2 실행 환경

두 가지 실행 환경이 정의된다. 프리스탠딩 환경과 호스트 환경이 있다. 두 경우 모두에서 프로그램 시작은, 실행 환경이 정해진 C 함수를 호출하는 것으로 일어난다. 정적 저장 기간을 갖는 모든 객체는 프로그램 시작 전에 초기화(각각의 초기값으로)되어야 한다. 그 밖에 구체적인 초기화 방식과 시점은 정하지 않는다. 프로그램 종료는 실행 환경에 제어권을 반환한다.

**전방 참조**: 초기화 ([3.5.7](#357-초기화)).

##### 2.1.2.1 독립 환경

프리스탠딩 환경(C 프로그램 실행이 운영체제의 도움 없이 이루어질 수 있는)에서는, 프로그램 시작시 호출되는 함수의 이름과 타입이 구현 정의를 따른다. 그 외에는 예약된 외부 식별자가 없다. 프리스탠딩 프로그램에서 사용할 수 있는 라이브러리 기능들은 모두 구현 정의된다.

프리스탠딩 환경에서 프로그램 종료의 효과 또한 구현에서 정의한다.

##### 2.1.2.2 호스트 환경

호스트 환경은 반드시 제공될 필요는 없지만, 만약 존재한다면 다음 규정을 따라야 한다.

"프로그램 시작"

프로그램 시작 시 호출되는 함수의 이름은 `main`이다. 구현은 이 함수에 대한 프로토타입을 선언하지 않는다. `main` 함수는 다음과 같이 매개변수 없이 정의될 수 있다.

```c
int main(void) { /*...*/ }
```

또는 다음과 같이 두 개의 매개변수로 정의될 수도 있다(여기서는 매개변수의 이름이 `argc`와 `argv`로 이지만, 이들은 선언된 함수 내부에서만 유효한 지역 변수이므로 어떤 이름을 사용해도 상관없다):

```c
int main(int argc, char *argv[]) { /*...*/ }
```

`main` 함수의 매개변수들이 정의되어 있다면, 매개변수들은 다음 제약을 따라야 한다:

* `argc`의 값은 음수가 아니어야 한다. 

* `argv[argc]`는 null 포인터여야 합니다.

* `argc` 값이 0보다 크다면, `argv[0]`부터 `argv[argc-1]`까지 포함하는 배열 멤버들에는 문자열을 가리키는 포인터들이 저장되어 있어야, 이 문자열들은 프로그램 시작 전에 호스트 환경에 의해 구현 정의된 값을 부여받는다. 의도는 호스트 환경의 다른 곳에서 프로그램 시작 전에 결정된 정보를 프로그램에 제공하는 것이다. 호스트 환경이 대문자와 소문자가 섞인 문자열을 제공할 수 없다면, 구현은 문자열이 소문자로 수신되도록 보장해야 한다.

* `argc` 값이 0보다 크다면, `argv[0]`이 가리키는 문자열은 프로그램 이름을 나타낸다. 호스트 환경에서 프로그램 이름을 쓸 수 없는 경우 `argv[0][0]`은 null 문자여야 합니다. `argc` 값이 1보다 크다면, `argv[1]`부터 `argv[argc-1]`까지가 가리키는 문자열들은 프로그램 매개변수를 나타낸다.

* 매개변수 `argc`와 `argv`, 그리고 `argv` 배열이 가리키는 문자열들은 프로그램에 의해 수정 가능해야 하며, 프로그램 시작부터 종료까지 마지막으로 저장된 값을 유지해야 한다.

"프로그램 실행"

호스트 환경에서, 프로그램은 라이브러리 절(4.)에 기술된 모든 함수, 매크로, 타입 정의, 객체들을 사용할 수 있다.

"프로그램 종료"

`main` 함수에 대한 최초 호출에서 `return`을 하는 것은, `main` 함수가 반환한 값을 인수로 하여 `exit` 함수를 호출하는 것과 동등하다. 만약 `main` 함수가 값을 지정하지 않은 `return`을 실행한다면, 호스트 환경으로 반환되는 종료 상태는 정의되지 않는다.

**전방 참조**: 용어 정의 ([4.1.1](#411-용어의-정의)), exit 함수 ([4.10.4.3 exit 함수](#41043-exit-함수)).

##### 2.1.2.3 프로그램 실행

본 표준의 의미론적 설명은 최적화 문제가 무관한 추상 기계의 동작을 기술한다.

`volatile` 객체에 접근하거나, 객체를 변경하거나, 파일을 수정하거나, 또는 이러한 작업 중 하나라도 수행하는 함수를 호출하는 것은 모두 부수 효과이며, 이는 실행 환경의 상태가 변하는 것을 의미한다. 수식의 평가도 부수 효과를 발생시킬 수 있다. 실행 순서 중에서 시퀀스 포인트라고 불리는 특정 시점들에서는, 이전 평가들에 의해 발생한 모든 부수 효과가 완료되어 있어야 하며, 이후에 평가될 어떤 부수 효과도 아직 발생하지 않아야 한다.

추상 기계에서 모든 식은 의미론에 규정된 대로 평가된다. 실제 구현에서는 어떤 수식의 일부가 사용되지 않는 값이고 필요한 부작용(함수 호출이나 `volatile` 객체 접근으로 인한 부수 효과 포함)이 발생하지 않는다고 추론할 수 있다면, 그 식의 일부를 평가하지 않아도 된다.

시그널 수신에 의해 추상 기계의 작동이 중단된 경우, 바로 이전 시퀀스 포인트 시점에서의 객체 값들만 신뢰할 수 있다. 바로 이전 시퀀스 포인트와 바로 다음 시퀀스 포인트 사이에서 변경될 수 있는 객체들은 아직 올바른 값을 갖지 못했을 수 있다.

자동 저장 기간을 갖는 각 객체의 인스턴스는 각 블록 진입과 관련이 있다. 그러한 객체는 블록의 실행 도중 및 블록이 (함수 호출이나 시그널 수신에 의해) 일시 중단된 동안에도 존재하며 마지막으로 저장된 값을 유지한다.

적합한 구현이 만족해야 하는 최소 요구사항은 다음과 같다:

* 시퀀스 포인트에서, `volatile` 객체들은 이전 평가들은 완료되었고 이후 평가는 아직 발생하지 않았다는 의미에서 안정적이어야 한다.

* 프로그램 종료 시, 파일에 기록된 모든 데이터는 추상 의미론에 따라 프로그램을 실행했을 때 생성되었어야 할 결과와 동일해야 한다.

* 대화형 장치의 입출력 동작 특성은 [4.9.3](#493-파일)에 규정된 대로 이루어져야 한다. 본 요구사항의 의도는 버퍼링되지 않은 출력이나 줄 단위로 버퍼링된 출력이 가능한 한 빨리 나타나게 하여, 프로그램이 입력을 기다리기 전에 프롬프트 메시지가 실제로 표시되는 것을 보장하는 것이다.

무엇이 대화형 장치인지는 구현에서 정의한다.

각 구현은 추상 의미론과 실제 의미론 사이의 더 엄격한 일치를 정의할 수도 있다.

"예제 (Examples)"

어떤 구현은 추상 의미론과 실제 의미론 사이에 일대일 대응을 정의할 수도 있습니다. 즉, 모든 시퀀스 포인트에서 실제 객체들의 값이 추상 의미론에 의해 정해진 값과 일치하게 만드는 것이다. 그런 구현에서는 `volatile` 키워드가 불필요해질 것이다.

반대로, 어떤 구현은 각 번역 단위 내에서 다양한 최적화를 수행하고, 번역 단위 경계를 넘나드는 함수 호출 시에만 실제 의미론이 추상 의미론과 일치하도록 할 수도 있습니다. 그런 구현에서는 호출하는 함수와 호출되는 함수가 서로 다른 번역 단위에 있을 때, 각 함수 진입 시점과 함수 반환 시점에, 외부 연결된 모든 객체들과 포인터를 통해 접근 가능한 모든 객체들의 값이 추상 의미론과 일치하게 된다. 더 나아가, 그러한 함수의 진입 시점에는 호출된 함수의 매개변수와 포인터를 통해 접근 가능한 모든 객체의 값이 추상 의미론과 일치한다. 그러한 유형의 구현에서는 `signal` 함수에 의해 활성화되는 인터럽트 서비스 루틴이 참조하는 객체들은 `volatile` 저장을 명시적으로 지정해야 하고, 그 외에도 구현 정의된 제약 사항들이 추가로 필요하게 된다.

다음 코드 조각을 실행할 때:

```c
char c1, c2;
/*...*/
c1 = c1 + c2;
```

"정수 승격" 규칙은 추상 기계가 각 변수의 값을 `int` 크기로 승격시킨 다음, 두 `int`를 더하고, 그 합을 잘라낼 것을 요구한다. 만약 두 `char`의 덧셈이 오버플로 예외를 발생시키지 않고 수행될 수 있다면, 실제 실행에서는 동일한 결과만 만들어내면 되며, 필요하다면 승격 과정을 생략할 수 있다.

마찬가지로, 다음 코드 조각에서:

```c
float f1, f2;
double d;
/*...*/
f1 = f2 * d;
```

만약 구현이 계산 결과가 배정밀도 연산을 사용했을 때와 동일하다는 것을 확실하게 알 수 있다면(예를 들어, `d`가 `double` 타입의 상수 `2.0`으로 대체된 경우), 곱셈은 단정밀도 연산을 사용하여 실행될 수 있다. 거꾸로, `int`나 `float`만 포함된 연산이라도 범위나 정밀도가 손실되지 않는다면 배정밀도 연산을 사용하여 실행될 수 있다.

**전방 참조**: 복합문, 또는 블록 ([3.6.2](#362-복합문-또는-블록)), 파일 ([4.9.3](#493-파일)), 시퀀스 포인트 ([3.3](#33-수식), [3.6](#36-문장)), signal 함수 ([4.7](#47-신호-처리-signalh)), 타입 한정자 ([3.5.3](#353-타입-한정자)).

### 2.2 환경 고려사항

#### 2.2.1 문자 집합

두 개의 문자 집합과 그에 연관된 정렬 순서가 정의되어야 한다. 하나는 소스 파일이 작성되는 문자 집합이고, 다른 하나는 실행 환경에서 해석되는 문자 집합이다. 실행 문자 집합 원소들의 값은 구현 정의다. 본 절의 요구사항 외의 추가적인 원소들은 로케일에 따라 달라진다.

문자 상수나 문자열 리터럴 안에서, 실행 문자 집합의 원소들은 대응되는 소스 문자 집합의 원소로 표현되거나, 역슬래시 `\` 뒤에 하나 이상의 문자가 이어지는 이스케이프 시퀀스로 표현되어야 한다. 모든 비트가 0으로 설정된 바이트인 null 문자가 기본 실행 문자 집합에 존재해야 하며, 이는 문자열 리터럴의 끝을 표시하는 데 사용된다.

기본 소스 문자 집합과 기본 실행 문자 집합은 모두 적어도 다음 원소들을 가져야 한다: 영어 알파벳 대문자 26개

>
> **A** **B** **C** **D** **E** **F** **G** **H** **I** **J** **K** **L** **M**
>
> **N** **O** **P** **Q** **R** **S** **T** **U** **V** **W** **X** **Y** **Z**
>

영어 알파벳 소문자 26개

>
> **a** **b** **c** **d** **e** **f** **g** **h** **i** **j** **k** **l** **m**
>
> **n** **o** **p** **q** **r** **s** **t** **u** **v** **w** **x** **y** **z**
>

10진수 숫자 10개

>
> **0** **1** **2** **3** **4** **5** **6** **7** **8** **9**
>

다음의 그래픽 문자 29개

>
>**\!** **\"** **\#** **\%** **\&** **\'** **\(** **\)** **\*** **\+** **\,** **\-** **\.** **\/** **\:**
>
> **\;** **\<** **\=** **\>** **\?** **\[** **\\** **\]** **\^** **\_** **\{** **\|** **\}** **\~**
>

공백 문자, 그리고 다음을 나타내는 제어 문자들: 수평 탭, 수직 탭, 폼 피드. 소스 및 실행 기본 문자 집합 모두에서, 위의 10진수 숫자 목록에서 `0` 다음에 오는 각 문자의 값은 이전 문자의 값보다 1 커야 한다. 소스 파일에는 텍스트의 각 줄의 끝을 표시하는 어떤 방법이 있어야 하며, 본 표준은 그러한 줄 끝 표시자를 마치 하나의 개행 문자인 것처럼 취급한다. 실행 문자 집합에는 경고, 백스페이스, 캐리지 리턴, 그리고 개행을 나타내는 제어 문자가 있어야 한다. 만약 소스 파일에서 (토큰으로 변환되지 않는 전처리 토큰, 문자 상수, 문자열 리터럴, 또는 주석 내부를 제외하고) 다른 문자가 발견된다면, 그 동작은 정의되지 않는다.

**전방 참조**: 문자 상수 ([3.1.3.4](#3134-문자-상수)), 전처리 지시문 ([3.8](#38-전처리-지시문)), 문자열 리터럴 ([3.1.4](#314-문자열-리터럴)), 주석 ([3.1.9](#319-주석)).

##### 2.2.1.1 삼중 문자 시퀀스

소스 파일 내에서 다음의 세 문자 시퀀스(삼중 문자 시퀀스[^5]라고 불림)가 나타나는 모든 곳은 그에 해당하는 단일 문자로 대체된다.

|   |   |
| :--- | :--- |
| `??=` | `#` |
| `??(` | `[` |
| `??/` | `\` |
| `??)` | `]` |
| `??'` | `^` |
| `??<` | `{` |
| `??!` | <code>\|</code> |
| `??>` | `}` |
| `??-` | `~` |

그 외 다른 삼중 문자 시퀀스는 존재하지 않는다. 위에 나열된 삼중 문자의 시작 부분이 아닌 `?` 문자는 변경되지 않는다.

###### 예제

다음 소스 라인은:
```c
         printf("Eh???/n");
```

(삼중 문자 시퀀스 ??/가 대체된 후) 다음과 같이 된다:

```c
         printf("Eh?\n");
```

##### 2.2.1.2 멀티 바이트 문자

소스 문자 집합은 확장 문자 집합의 원소를 표현하기 위해 사용되는 멀티바이트 문자를 포함할 수 있다. 실행 문자 집합 또한 멀티바이트 문자를 포함할 수 있으며, 이 때 실행 문자 집합의 인코딩과 소스 문자 집합의 인코딩은 동일할 필요가 없다. 두 문자 집합 모두에 대해 다음 사항이 성립해야 한다:

* [2.2.1](#221-문자-집합)에서 정의된 단일 바이트 문자들은 반드시 존재해야 한다.

* 추가적인 원소들의 존재 여부, 의미, 그리고 표현 방식은 로케일에 따라 다르다.

* 멀티바이트 문자는 상태 의존적 인코딩을 가질 수 있다. 상태 의존적 인코딩에서 각 멀티바이트 문자 시퀀스는, 초기 시프트 상태에서 시작하며, 시퀀스 내에서 특정 멀티바이트 문자를 만나면 구현 정의된 다른 시프트 상태로 진입한다. 초기 시프트 상태에 있는 동안, 모든 단일 바이트 문자는 평소의 해석을 유지하며 시프트 상태를 변경하지 않는다. 시퀀스 내의 후속 바이트들에 대한 해석은 현재의 시프트 상태에 대한 함수가 된다.

* 모든 비트가 0인 바이트는 시프트 상태와 무관하게 null 문자로 해석되어야 한다.

* 모든 비트가 0인 바이트는 멀티바이트 문자의 두 번째 또는 그 이후 바이트로는 나타나면 안된다.

소스 문자 집합에 대해서는, 다음 사항이 성립해야 한다:

* 주석, 문자열 리터럴, 문자 상수, 헤더 이름은 초기 시프트 상태에서 시작하고 끝나야 한다.

* 주석, 문자열 리터럴, 문자 상수, 헤더 이름은 유효한 멀티바이트 문자들의 시퀀스로 구성되어야 합니다.

#### 2.2.2 문자 표시 의미론

활성 위치는 `fputc` 함수가 출력하는 다음 문자가 디스플레이 장치에 나타날 위치를 말한다. 디스플레이 장치에 인쇄 가능 문자(`isprint` 함수에 의해 정의된)을 기록한다는 것의 의도는, 해당 문자의 그래픽 표현을 활성 위치에 표시한 다음에 활성 위치를 현재 줄의 다음 위치로 이동시키는 것이다. 출력 방향은 로케일에 따라 달라진다. 만약 활성 위치가 줄의 마지막 위치에 있다면(마지막 위치라는 것이 존재할 때), 그 동작은 규정되지 않는다.

실행 문자 집합에서 그래픽 표현이 없는 문자를 나타내는 알파벳 이스케이프 시퀀스들은 디스플레이 장치에서 다음과 같은 동작을 수행하도록 의도되었다: 

|||
|:---------|:---|
|alert|청각적 또는 시각적 경고를 발생시킨다. 활성 위치는 변경되지 않아야 한다.|
|backspace|활성 위치를 현재 줄의 이전 위치로 이동시킨다. 만약 활성 위치가 줄의 시작 위치라면, 그 동작은 규정되지 않는다.|
|form feed|활성 위치를 다음 논리 페이지의 시작 위치로 이동한다.|
|new line|활성 위치를 다음 줄의 시작 위치로 이동한다.|
|carriage return|활성 위치를 현재 줄의 시작 위치로 이동한다.|
|horizontal tab|활성 위치를 현재 줄의 다음 수평 탭 정지 위치로 이동한다. 만약 활성 위치가 정의된 마지막 수평 탭 정지 위치에 있거나 그 위치를 지났다면, 동작은 규정되지 않는다.|
|vertical tab|활성 위치를 다음 수직 탭 정지 위치의 시작 위치로 이동한다. 만약 활성 위치가 정의된 마지막 수직 탭 정지 위치에 있거나 그 위치를 지났다면, 동작은 규정되지 않는다.|

각 이스케이프 시퀀스는 단일 `char` 객체에 저장될 수 있는 고유한 값을 구현에서 정의된대로 생성해야 한다. 텍스트 파일에서의 외부 표현은 내부 표현과 반드시 동일할 필요는 없으며, 이는 이 표준의 범위를 벗어난다.

**전방 참조**: fputc 함수 ([4.9.7.3](#4973-fputc-함수)), isprint 함수 ([4.3.1.7](#4317-isprint-함수)).

#### 2.2.3 신호와 인터럽트

함수들은 실행중 어떤 시점에서든지 시그널에 의해 중단되거나, 시그널 핸들러에 의해 호출되거나, 혹은 두 상황이 모두 발생하더라도, 이전에 활성화되어 있던 호출의 제어 흐름 (인터럽트가 끝난 이후에), 함수 반환값, 자동 저장 기간의 객체들에 변화가 없도록 구현되어야 한다. 그러한 모든 객체는 함수 이미지(함수의 실행 가능한 표현을 구성하는 명령어들) 밖에서 호출될 때마다 별도로 관리되어야 한다.

표준 라이브러리의 함수들은 재진입 허용이 보장되지 않으며, 정적 저장 기간을 가진 객체들을 수정할 수도 있다.

#### 2.2.4 환경 한계

번역 환경과 실행 환경은 모두 언어 번역기와 라이브러리의 구현을 제약한다. 다음은 적합한 구현에 대한 환경적 한계를 요약한 것이다.

##### 2.2.4.1 번역 한계

구현은 다음 한계들 각각에 대해 사례를 하나 이상 포함하는 프로그램을, 최소한 하나는 번역하고 실행할 수 있어야 한다.[^6]

* 복합문, 반복 제어 구조, 선택 제어 구조의 중첩 15단계

* 조건부 포함의 중첩 8단계

* 선언 내에서 산술, 구조체, 공용체, 또는 불완전 타입을 수식하는 포인터, 배열, 함수 선언자 12개

* 전체 선언자 내에서 괄호로 중첩된 선언자 31개 

* 전체 수식 내에서 괄호로 중첩된 식 32개

* 내부 식별자 또는 매크로 이름에서 유효한 문자 개수 앞에서부터 31개

* 외부 식별자에서 유효 문자 개수 앞에서부터 6개

* 하나의 번역 단위 내에 있는 외부 식별자 511개

* 하나의 블록 안에 선언된, 블록 유효 범위를 가진 식별자 127개

* 하나의 번역 단위 내에 동시에 정의된 매크로 식별자 1024개

* 하나의 함수 정의에서 매개변수 31개

* 하나의 함수 호출에서 인수 31개 

* 하나의 매크로 정의에서 매개변수 31개 

* 하나의 매크로 호출에서 인수 31개

* 하나의 논리적 소스 줄에서 문자 509개

* 하나의 문자열 리터럴 또는 와이드 문자열 리터럴에서 (연결 후) 문자 509개의 

* 하나의 객체의 크기 32767 바이트 (호스트 환경 전용)

* `#include`된 파일의 중첩 8단계 

* 하나의 `switch` 문에서 257개의 `case` 라벨 (중첩되어 있는 `switch` 문의 라벨은 제외)

* 단일 구조체 또는 공용체의 멤버 127개 

* 단일 열거 타입 내의 열거 상수 127개 

* 단일 구조체 선언 목록 내에서 중첩된 구조체 또는 공용체 정의 15단계

##### 2.2.4.2 수치 한계

적합한 구현은 이 절에 지정된 모든 한계를 문서화해야 하며, 이는 헤더 `<limits.h>`와 `<float.h>`에 명시되어야 한다.

"정수형의 크기 `<limits.h>`"

아래에 제시된 값들은 `#if` 전처리 지시문에서 사용하기에 적합한 상수 표현식으로 대체되어야 한다. 구현 정의된 값들은 아래에 표시된 값들과 비교하여 부호는 같고 그 크기(절대값)은 같거나 더 커야 한다.

* 비트 필드가 아닌 가장 작은 객체의 최대 비트 수 (바이트) `CHAR_BIT` `8`
* `signed char` 타입 객체의 최솟값 `SCHAR_MIN` `-127`
* `signed char` 타입 객체의 최댓값 `SCHAR_MAX` `+127`
* `unsigned char` 타입 객체의 최댓값 `UCHAR_MAX` `255`
* `char` 타입 객체의 최솟값 `CHAR_MIN` 아래 참조
* `char` 타입 객체의 최댓값 `CHAR_MAX` 아래 참조
* 지원되는 모든 로케일에서 멀티바이트 문자의 최대 바이트 수 `MB_LEN_MAX` `1`
* `short int` 타입 객체의 최솟값 `SHRT_MIN` `-32767`
* `short int` 타입 객체의 최댓값 `SHRT_MAX` `+32767`
* `unsigned short int` 타입 객체의 최댓값 `USHRT_MAX` `65535`
* `int` 타입 객체의 최솟값 `INT_MIN` `-32767`
* `int` 타입 객체의 최댓값 `INT_MAX` `+32767`
* `unsigned int` 타입 객체의 최댓값 `UINT_MAX` `65535`
* `long int` 타입 객체의 최솟값 `LONG_MIN` `-2147483647`
* `long int` 타입 객체의 최댓값 `LONG_MAX` `+2147483647`
* `unsigned long int` 타입 객체의 최댓값 `ULONG_MAX` `4294967295`

만약 `char` 타입 객체의 값이 수식에서 사용될 때 부호 확장된다면, `CHAR_MIN`의 값은 `SCHAR_MIN`과 같아야 하고 `CHAR_MAX`의 값은 `SCHAR_MAX`와 같아야 한다. 만약 `char` 타입 객체의 값이 수식에서 사용될 때 부호 확장되지 않는다면, `CHAR_MIN`의 값은 `0`이어야 하고 `CHAR_MAX`의 값은 `UCHAR_MAX`와 같아야 한다.[^7]

"실수 타입의 특성 `<float.h>`"

실수 타입의 특성은 실수의 표현을 기술하는 모델과, 구현의 실수 연산에 대한 정보를 제공하는 값들에 의해 정의된다. 다음 매개변수들은 각 실수 타입에 대한 모델을 정의하는 데 사용된다:

정규화된 실수 $x$ ($x$가 다음 모델에 의해 정의되는 경우 $f_1 > 0$):[^8]

```math
x = s \times b^e \times \sum_{k=1}^p f_k \times b^{-k}, \quad e_{min} \le e \le e_{max}
```

`<float.h>` 헤더에 있는 값들 중에서, `FLT_RADIX`는 `#if` 전처리 지시문에서 사용하기에 적합한 상수 표현식이어야 하며, 다른 모든 값은 반드시 상수 표현식일 필요는 없다. `FLT_RADIX`와 `FLT_ROUNDS`를 제외한 모든 값은 세 가지 부동 소수점 타입 각각에 대해 별도의 이름을 가진다. 부동 소수점 모델 표현은 `FLT_ROUNDS`를 제외한 모든 값에 대해 제공된다.

실수 덧셈에 대한 반올림 모드는 `FLT_ROUNDS`의 값에 따라 정해진다: `-1`: 결정할 수 없음, `0`: 0을 향해 반올림, `1`: 가장 가까운 값으로 반올림, `2`: 양의 무한대 방향으로, `3`: 음의 무한대 방향으로. 그 외의 값은 구현 정의된 반올림 동작을 의미한다.

다음 목록에 주어진 값들은 구현 정의된 수식으로 대체되어야 하며, 표시된 값들과 비교하여 부호가 같고 그 크기(절댓값)가 같거나 더 커야 합니다.

* 지수 표현의 기수, $b$:

|   |   |
| :--- | :--- |
| `FLT_RADIX` | `2` |

* 실수 가수를 기수-`FLT_RADIX`로 나타냈을 때 자릿수, $p$:

|   |   |
| :--- | :----- |
| `FLT_MANT_DIG` |   |
| `DBL_MANT_DIG` |   |
| `LDBL_MANT_DIG` |   |
    
* 십진수 정밀도의 자릿수:
```math
\lfloor (p - 1) \times \log_{10} b \rfloor + 
\begin{cases} 
1 & \text{if } b \text{ 가 10의 거듭제곱이면} \\ 
0 & \text{그 외} 
\end{cases}
```

|   |   |
| :--- | :----- |
| `FLT_DIG` | `6` |
| `DBL_DIG` | `10` |
| `LDBL_DIG` |  `10` |

* `FLT_RADIX`의 거듭제곱에서 1을 뺀 값이 정규화된 부동 소수점 수가 되는 최소 음의 정수, $e_{min}$:

|   |   |
| :--- | :----- |
| `FLT_MIN_EXP` |   |
| `DBL_MIN_EXP` |   |
| `LDBL_MIN_EXP` |   |

* 10에 거듭제곱을 했을 때 정규화된 부동 소수점 수의 범위 내에 있는 최소 음의 정수:

|   |   |
| :--- | :----- |
| `FLT_MIN_10_EXP` | `-37` |
| `DBL_MIN_10_EXP` | `-37` |
| `LDBL_MIN_10_EXP` | `-37` |

* `FLT_RADIX`의 거듭제곱에서 1을 뺀 값이 표현 가능한 실수가 되는 최대 정수, $e_{max}$:

|   |   |
| :--- | :----- |
| `FLT_MAX_EXP` |   |
| `DBL_MAX_EXP` |   |
| `LDBL_MAX_EXP` |   |

* 10에 거듭제곱을 했을 때 표현 가능한 실수의 범위 내에 있는 최대 정수:
    * `FLT_MAX_10_EXP`: +37
    * `DBL_MAX_10_EXP`: +37
    * `LDBL_MAX_10_EXP`: +37

다음 목록에 제시된 값들은 구현 정의된 표현식으로 대체되어야 하며, 표시된 값들과 같거나 더 커야 한다.

* 표현 가능한 최대 실수:

|   |   |
| :--- | :----- |
| `FLT_MAX` | `1E+37` |
| `DBL_MAX` | `1E+37` |
| `LDBL_MAX` | `1E+37` |

다음 목록에 제시된 값들은 구현 정의된 표현식으로 대체되어야 하며, 표시된 값들과 같거나 더 작아야 한다.

* $1.0 + x \neq 1.0$을 만족하는 최소 양의 실수 $x$:

|   |   |
| :--- | :----- |
| `FLT_EPSILON` | `1E-5` |
| `DBL_EPSILON` | `1E-9` |
| `LDBL_EPSILON` | `1E-9` |

* 최소의 정규화된 양의 실수, $b^{e_{min}-1}$:

|   |   |
| :--- | :----- |
| `FLT_MIN` | `1E-37` |
| `DBL_MIN` | `1E-37` |
| `LDBL_MIN` | `1E-37` |

### 예제 (Examples)

다음은 표준의 최소 요구사항을 충족하는 인공적인 실수 표현과, `float` 타입에 대한 `<float.h>` 헤더의 적절한 값들을 설명한다:

```math
x = s \times 16^e \times \sum_{k=1}^6 f_k \times 16^{-k}, \quad -31 \le e \le +32
```
<br/>

|   |   |
| :--- | :--- |
| `FLT_RADIX` | `16` |
| `FLT_MANT_DIG` | `6` |
| `FLT_EPSILON` | `9.53674316E-07F` |
| `FLT_DIG` | `6` |
| `FLT_MIN_EXP` | `-31` |
| `FLT_MIN` | `2.93873588E-39F` |
| `FLT_MIN_10_EXP` | `-38` |
| `FLT_MAX_EXP` | `+32` |
| `FLT_MAX` | `3.40282347E+38F` |
| `FLT_MAX_10_EXP` | `+38` |

다음은 IEEE 이진 부동 소수점 연산 표준 (ANSI/IEEE Std 754-1985)[^9]의 단정밀도 및 배정밀도 정규화 수 요구사항을 충족하는 실수 표현과, `float` 및 `double` 타입에 대한 `<float.h>` 헤더의 적절한 값들을 설명한다:

```math
x_f = s \times 2^e \times \sum_{k=1}^{24} f_k \times 2^{-k}, \quad -125 \le e \le +128
```

```math
x_d = s \times 2^e \times \sum_{k=1}^{53} f_k \times 2^{-k}, \quad -1021 \le e \le +1024
```
<br/>

|   |   |   |   |
| :--- | :--- | :--- | :--- |
| `FLT_RADIX` | `2` |   |   |
| `FLT_MANT_DIG` | `24` | `DBL_MANT_DIG` | `53` |
| `FLT_EPSILON` | `1.19209290E-07F` | `DBL_EPSILON` | `2.2204460492503131E-16` |
| `FLT_DIG` | `6` | `DBL_DIG` | `15` |
| `FLT_MIN_EXP` | `-125` | `DBL_MIN_EXP` | `-1021` |
| `FLT_MIN` | `1.17549435E-38F` | `DBL_MIN` | `2.2250738585072016E-308` |
| `FLT_MIN_10_EXP` | `-37` | `DBL_MIN_10_EXP` | `-307` |
| `FLT_MAX_EXP` | `+128` | `DBL_MAX_EXP` | `+1024` |
| `FLT_MAX` | `3.40282347E+38F` | `DBL_MAX` | `1.7976931348623157E+308` |
| `FLT_MAX_10_EXP` | `+38` | `DBL_MAX_10_EXP` | `+308` |

위에 표시된 `FLT_EPSILON`과 `DBL_EPSILON` 값은 ANSI/IEEE Std 754-1985의 기본 반올림 모드(가장 가까운 값으로 반올림)에 적합하다. 다른 반올림 모드에서는 값들이 다를 수 있다.

**전방 참조**: 조건부 포함 ([3.8.1](#381-조건부-포함)).

## 3. 언어

언어 절 ([3.](#3-언어))에서 쓰이는 구문 표기법에서, 구문 범주(비단말 기호)는 *기울임꼴*로 표시되며, 리터럴 단어와 문자 집합의 구성 요소(단말 기호)는 **굵게** 표시된다. 비단말 기호 뒤에 붙는 콜론(:)은 해당 기호를 정의한다는 것을 나타낸다. 대체 정의들은 별도의 줄에 나열되지만, "one of"라는 문구가 앞에 붙는 경우는 예외다. 선택적 기호들은 아래첨자 <sub>옵션</sub>를 통해 표시된다. 다음

**{** &nbsp; *수식<sub>옵션</sub>* &nbsp; **}**

에서는 생략 가능한 수식이 중괄호 안에 들어간다. 

### 3.1 어휘 요소

###### 문법

*토큰:*
>
> [*키워드*](#311-키워드)
>
> [*식별자*](#312-식별자)
>
> [*상수*](#313-상수)
>
> [*문자열 리터럴*](#314-문자열-리터럴)
>
> [*연산자*](#315-연산자)
>
> [*구두점*](#316-구두점)
>
*전처리-토큰:*
>
> [*헤더 이름*](#317-헤더-이름)
>
> [*식별자*](#312-식별자)
>
> [*전처리 숫자*](#318-전처리-숫자)
>
> [*문자 상수*](#3134-문자-상수)
>
> [*문자열 리터럴*](#314-문자열-리터럴)
>
> [*연산자*](#315-연산자)
>
> [*구두점*](#316-구두점)
>
> **<sub>위의 범주에 해당하지 않는 공백이 아닌 문자</sub>**
>
###### 제약

토큰으로 변환되는 각 전처리 토큰은 반드시 키워드, 식별자, 상수, 문자열 리터럴, 연산자, 또는 구두점의 어휘적 형태를 갖추어야 한다.

###### 의미

토큰은 번역 단계 7과 8에서의 언어의 최소 어휘 단위이다. 토큰의 범주는 키워드, 식별자, 상수, 문자열 리터럴, 연산자, 구두점이다. 전처리 토큰은 번역 단계 3에서 6까지의 언어의 최소 어휘 단위이다. 전처리 토큰의 범주는 헤더 이름, 식별자, 전처리 숫자, 문자 상수, 문자열 리터럴, 연산자, 구두점, 그리고 다른 전처리 토큰 범주에 어휘적으로 일치하지 않는 단일 비공백 문자들이다. 만약 `'` 또는 `"` 문자가 이 마지막 범주에 해당한다면, 그 동작은 정의되지 않는다. 주석(뒤에서 설명한다)와 띄어쓰기, 수평 탭, 줄바꿈, 수직 탭, 폼 피드 문자들 --- 통칭하여 공백이라 부른다 --- 는 전처리 토큰들을 분리하는 역할을 할 수 있다. [3.8](#38-전처리-지시문)절에서 설명하듯, 번역 단계 4의 특정 상황에서는 공백(또는 공백의 부재)가 단순한 전처리 토큰 분리 이상의 역할을 하기도 한다. 공백은 헤더 이름의 일부이거나, 문자 상수 또는 문자열 리터럴의 따옴표 문자 사이에 있는 경우에만 전처리 토큰 내부에 나타날 수 있다.

입력 스트림이 특정 문자까지 전처리 토큰으로 구문 분석되었다면, 그다음 전처리 토큰은 전처리 토큰을 구성할 수 있는 가장 긴 문자 시퀀스가 된다.

###### 예제

프로그램 조각 `1Ex`는 (유효한 실수 상수나 정수 상수 토큰이 아님에도 불구하고) 하나의 전처리 숫자 토큰으로 파싱된다. 만약 이를 `1`과 `Ex`라는 두 개의 전처리 토큰 쌍으로 파싱했다면 유효한 수식이 될 수도 있었을 것임에도 불구하고 그렇다 (예를 들어 `Ex`가 `+1`로 정의된 매크로일 때). 비슷하게, 프로그램 조각 `1E1`은 `E`가 매크로 이름인지 여부와 관계없이 하나의 전처리 숫자(유효한 부동 소수점 상수 토큰인 것)로 파싱된다.

프로그램 조각 `x+++++y`는 증감 연산자의 제약사항을 위반하는 `x ++ ++ + y` 식으로 파싱된다. 비록 `x ++ + ++ y`로 파싱하는 것이 올바른 표현식을 생성할 수 있을지라도 그렇다.

**전방 참조**: 문자 상수 ([3.1.3.4](#3134-문자-상수)), 주석 ([3.1.9](#319-주석)), 표현식 ([3.3](#33-수식)), 부동 소수점 상수 ([3.1.3.1](#3131-실수-상수)), 헤더 이름 ([3.1.7](#317-헤더-이름)), 매크로 교체 ([3.8.3](#383-매크로-치환)), 후위 증가 및 감소 연산자 ([3.3.2.4](#3324-후위-증감-연산자)), 전위 증가 및 감소 연산자 ([3.3.3.1](#3331-전위-증감-연산자)), 전처리 지시문 ([3.8](#38-전처리-지시문)), 전처리 숫자 ([3.1.8](#318-전처리-숫자)), 문자열 리터럴 ([3.1.4](#314-문자열-리터럴))

#### 3.1.1 키워드

###### 문법

*키워드:* <sub>다음 중 하나</sub>
> 
> **auto** **double** **int** **struct**
> 
> **break** **else** **long** **switch**
> 
> **case** **enum** **register** **typedef**
> 
> **char** **extern** **return** **union**
> 
> **const** **float** **short** **unsigned**
> 
> **continue** **for** **signed** **void**
> 
> **default** **goto** **sizeof** **volatile**
> 
> **do** **if** **static** **while**
> 
###### 의미

위 토큰들은 (전부 소문자) 번역 단계 7과 8에서 키워드로 사용하기 위해 예약되어 있으므로, 그 외의 용도로 써서는 안된다.

#### 3.1.2 식별자

###### 문법

<a name="identifier"></a>
*식별자:*
>
> [*비숫자*](#nondigit)
>
> [*식별자*](#identifier) &nbsp; [*비숫자*](#nondigit)
>
> [*식별자*](#identifier) &nbsp; [*숫자*](#digit)
>
<a name="nondigit"></a>
*비숫자:* <sub>다음 중 하나</sub>
> 
> **_** **a** **b** **c** **d** **e** **f** **g** **h** **i** **j** **k** **l** **m**
> 
> **n** **o** **p** **q** **r** **s** **t** **u** **v** **w** **x** **y** **z**
> 
> **A** **B** **C** **D** **E** **F** **G** **H** **I** **J** **K** **L** **M**
> 
> **N** **O** **P** **Q** **R** **S** **T** **U** **V** **W** **X** **Y** **Z**
> 
<a name="digit"></a>
*숫자:* <sub>다음 중 하나</sub>
> 
> **0** **1** **2** **3** **4** **5** **6** **7** **8** **9**
> 
###### 설명

식별자는 비숫자 문자(밑줄 `_`과 영문 소문자 및 대문자 포함)와 숫자의 연속이다. 첫 번째 문자는 반드시 비숫자 문자여야 한다.

###### 제약

번역 단계 7과 8에서, 식별자는 키워드와 동일한 문자 시퀀스로 구성되어서는 안 된다.

###### 의미

식별자는 객체, 함수, 또는 뒤에서 설명할 다음 개체 중 하나를 지칭한다: 구조체, 공용체, 열거 타입의 태그나 멤버, `typedef` 이름, 라벨 이름, 매크로 이름, 또는 매크로 매개변수. 열거 타입의 멤버는 열거 상수라고 부른다. 매크로 이름과 매크로 매개변수는 여기서는 더 이상 다루지 않는데, 이는 프로그램 번역의 의미 분석 단계 이전에 소스 파일 내의 모든 매크로 이름이 해당 매크로 정의를 구성하는 전처리 토큰 시퀀스로 대체되기 때문이다.

식별자의 최대 길이에는 구체적인 제한이 없다.

"구현 제한"

구현체는 내부 이름(매크로 이름이나 외부 연결을 갖지 않는 식별자)의 경우 최소한 처음 31자까지를 유효한 것으로 취급해야 한다. 대응하는 소문자와 대문자는 서로 다른 것으로 취급한다. 구현체는 외부 이름(외부 연결을 갖는 식별자)의 유효성을 6자로 더 제한할 수 있으며, 이러한 이름에 대해서는 알파벳 대소문자 구분을 무시할 수도 있다.[^10] 식별자에 대한 이러한 제한사항들은 모두 구현 정의 사항이다.

유효한 문자 내에서 차이가 있는 식별자는 서로 다른 식별자이다. 만약 두 식별자가 유효하지 않은 문자 부분에서만 다르다면, 그 동작은 정의되지 않는다.

**전방 참조**: 식별자의 연결 ([3.1.2.2](#3122-식별자의-연결)), 매크로 치환 ([3.8.3](#383-매크로-치환))

##### 3.1.2.1 식별자의 유효 범위

식별자는 유효 범위라고 불리는 프로그램 텍스트의 특정 영역 내에서만 가시적이다(사용될 수 있다). 유효 범위에는 함수, 파일, 블록, 함수 원형의 네 가지 종류가 있다. (함수 원형이란 매개변수의 타입을 선언하는 함수 선언을 말한다.)

라벨 이름은 함수 유효 범위를 가지는 유일한 식별자이다. 라벨 이름은 그것이 등장하는 함수 내 어디서든(`goto` 문에서) 사용될 수 있으며, 구문적 형태(뒤에 `:`과 문장이 옴)에 의해 자동적으로 선언된다. 라벨 이름은 함수 내에서 유일해야 한다.

그 외의 모든 식별자는 선언의 위치(선언자 또는 타입 지정자 내부)에 따라 유효 범위가 결정된다. 식별자를 선언하는 선언자나 타입 지정자가 모든 블록이나 매개변수 목록의 외부에 위치하면, 그 식별자는 파일 유효 범위를 가지며, 이는 번역 단위의 끝에서 종료된다. 식별자를 선언하는 선언자나 타입 지정자가 블록 내부나 함수 정의의 매개변수 선언 목록 내에 위치하면, 그 식별자는 블록 유효 범위를 가지며, 이는 해당 블록을 닫는 `}`에서 종료된다. 식별자를 선언하는 선언자나 타입 지정자가 함수 원형(함수 정의의 일부가 아님) 내의 매개변수 선언 목록 내에 위치하면, 그 식별자는 함수 원형 유효 범위를 가지며, 이는 함수 선언자의 끝에서 종료된다. 만약 같은 이름 공간 내에 어휘적으로 동일한 식별자의 외부 선언이 존재한다면, 그 외부 선언은 현재 유효 범위가 종료될 때까지 가려지며, 종료된 후 다시 가시화된다.

구조체, 공용체, 열거 타입 태그의 유효 범위는 해당 태그를 선언하는 타입 지정자에서 태그가 등장한 직후 시작된다. 각 열거 상수의 유효 범위는 열거자 목록에서 자신을 정의하는 열거자가 등장한 직후 시작된다. 그 외의 모든 식별자는 선언자가 완료된 직후부터 유효 범위가 시작된다.

**Forward references**: 복합 문장, 또는 블록 ([3.6.2](#362-복합문-또는-블록)), 선언 ([3.5](#35-선언)), 열거체 지정자 ([3.5.2.2](#3522-열거체-지정자)), 함수 호출 ([3.3.2.2](#3322-함수-호출)), 함수 선언자(프로토타입 포함) ([3.5.4.3](#3543-함수-선언자프로토타입-포함)), 함수 정의 ([3.7.1](#371-함수-정의)), goto 문 ([3.6.6.1](#3661-goto-문)), 라벨문 ([3.6.1](#361-라벨이-붙은-문장)), 식별자의 이름 공간 ([3.1.2.3 식별자의 이름 공간](#3123-식별자의-이름-공간)), 매크로 정의의 범위 ([3.8.3.5](#3835-매크로-정의의-범위)), 소스 파일 포함 ([3.8.2](#382-소스-파일-포함)), 태그 ([3.5.2.3](#3523-태그)), 타입 지정자 ([3.5.2](#352-타입-지정자)).


##### 3.1.2.2 식별자의 연결

서로 다른 유효 범위에서 선언되거나 동일한 유효 범위 내에서 여러 번 선언된 식별자는 연결이라는 과정을 통해 동일한 객체나 함수를 가리키도록 만들어질 수 있다. 연결에는 외부 연결, 내부 연결, 무연결의 세 가지 종류가 있다.

전체 프로그램을 구성하는 번역 단위와 라이브러리의 집합 내에서, 외부 연결을 갖는 특정 식별자의 각 인스턴스는 동일한 객체나 함수를 지칭한다. 하나의 번역 단위 내에서, 내부 연결을 갖는 식별자의 각 인스턴스는 동일한 객체나 함수를 지칭한다. 연결이 없는 식별자는 각각 고유한(별개의) 개체를 지칭한다.

객체나 함수에 대한 식별자 선언이 파일 유효 범위를 가지며 저장소 클래스 지정자 `static`을 포함하는 경우, 그 식별자는 내부 연결을 갖는다.

객체나 함수에 대한 식별자 선언이 저장소 클래스 지정자 `extern`을 포함하는 경우, 파일 유효 범위를 가진 가시적인 선언이 이미 존재한다면, 그 식별자는 해당 선언과 동일한 연결을 갖는다. 파일 유효 범위를 가진 가시적인 선언이 없다면, 그 식별자는 외부 연결을 갖는다.

함수에 대한 식별자 선언에 저장소 클래스 지정자가 없다면, 그 연결은 마치 extern 지정자와 함께 선언된 것처럼 결정된다. 객체에 대한 식별자 선언이 파일 유효 범위를 가지며 저장소 클래스 지정자가 없다면, 그 연결은 외부 연결이다.

다음 식별자들은 연결을 갖지 않는다: 객체나 함수가 아닌 것으로 선언된 식별자, 함수 매개변수로 선언된 식별자, 블록 내부에서 `extern` 지정자 없이 객체로 선언된 식별자.

만약 하나의 번역 단위 내에서 동일한 식별자가 내부 연결과 외부 연결을 동시에 가지고 나타난다면, 그 동작은 정의되지 않는다.

**전방 참조**: 복합문, 또는 블록 ([3.6.2](#362-복합문-또는-블록)), 선언 ([3.5](#35-선언)), 수식 ([3.3](#33-수식)), 외부 정의([3.7](#37-외부-정의))

##### 3.1.2.3 식별자의 이름 공간

만약 번역 단위 내의 특정 지점에서, 어떤 특정 식별자에 대한 선언이 두 개 이상 가시적이라고 하더라도, 구문적 문맥이 서로 다른 개체를 가리키는 용례들을 구분해준다. 따라서, 다음과 같이 식별자의 다양한 범주에 대해 별도의 이름 공간들이 존재한다:

* 라벨 이름 (라벨 선언 및 사용시 구문 형태에 의해 구분된다);

* 구조체, 공용체, 및 열거 타입의 태그 (`struct`, `union`, `enum` 키워드 중 하나 [^11] 뒤에 따라옴으로써 구분된다);

* 구조체 또는 공용체의 멤버; 각 구조체나 공용체는 자신의 멤버들에 대해 별도의 이름 공간을 가진다 (`.` 또는 `->` 연산자를 통해 멤버에 접근할 때 사용되는 표현식의 타입에 의해 구분된다);

* 다른 모든 식별자, 일반 식별자로 불린다 (일반 선언자 내에서 선언되거나 열거 상수로 선언된 것들이다).

**전방 참조**: 선언자 ([3.5.4](#354-선언자)), 열거 타입 지정자 ([3.5.2.2](#3522-열거체-지정자)), 라벨문 ([3.6.1](#361-라벨이-붙은-문장)), 구조체 및 공용체 지정자 ([3.5.2.1](#3521-구조체-및-공용체-지정자)), 구조체 및 공용체 멤버 ([3.3.2.3](#3323-구조체-및-공용체-멤버)), 태그 ([3.5.2.3](#3523-태그)).

##### 3.1.2.4 객체의 저장 기간

객체는 지속시간을 결정하는 저장 기간을 가진다. 저장 기간에는 정적과 자동 두 가지가 있다.

외부 연결이나 내부 연결로 선언된 객체, 또는 저장소 클래스 지정자 `static`으로 선언된 객체는 정적 저장 기간을 가진다. 그러한 객체의 경우, 저장 공간은 프로그램 시작 전에 단 한 번 확보되고 저장된 값도 단 한 번 초기화된다. 그 객체는 프로그램 전체 실행 도중 계속 존재하며 마지막으로 저장된 값을 유지한다.[^12]

연결이 없고 저장소 클래스 지정자 `static` 없이 선언된 객체는 자동 저장 기간을 가진다. 그러한 객체의 새로운 인스턴스를 위한 저장 공간은, 해당 객체가 선언된 블록으로 일반적인 진입을 할 때, 또는 블록 외부에서 블록 내부(혹은 포함된 내부 블록)의 라벨로 점프할 때마다 확보되는 것이 보장된다. 만약 객체에 저장될 값에 대한 초기화가 명시되어 있다면, 이는 블록으로의 각 일반적인 진입 시에는 수행되지만, 라벨로의 점프를 통해 블록에 진입한 경우에는 수행되지 않는다. 블록의 실행이 어떤 방식으로든 끝나면 해당 객체에 대한 저장 공간 확보는 더 이상 보장되지 않는다. (포함된 내부 블록으로 진입하는 것은 감싸는 외부 블록의 실행을 일시 중단시키지만 끝내지는 않는다. 값을 반환하는 함수를 호출하는 것은 그 호출을 포함하는 블록의 실행을 일시 중단시키지만 끝내지는 않는다.) 더 이상 확보가 보장되지 않는 자동 저장 기간의 객체를 참조했던 포인터의 값은 불확정적이다.

**전방 참조**: 복합문, 또는 블록 ([3.6.2](#362-복합문-또는-블록)), 함수 호출 ([3.3.2.2](#3322-함수-호출)), 초기화 ([3.5.7](#357-초기화)).

##### 3.1.2.5 타입

객체에 저장되거나 함수에 의해 반환되는 값의 의미는 해당 값에 접근하는 데 사용되는 수식의 타입에 따라 결정된다. (객체로 선언된 식별자는 가장 간단한 형태의 수식이며, 그 타입은 식별자의 선언문에 명시된다.) 타입은 객체 타입(객체를 설명하는 타입), 함수 타입(함수를 설명하는 타입), 그리고 불완전 타입(객체를 설명하지만 크기를 결정하는 데 필요한 정보가 부족한 타입)으로 구분된다.

`char` 타입으로 선언된 객체는 기본 실행 문자 집합의 모든 멤버를 저장할 수 있을 만큼 충분히 크다. [2.2.1](#221-character-sets) 항에 열거된 필수 소스 문자 집합의 멤버가 `char` 객체에 저장될 경우, 그 값은 양수임이 보장된다. 그 외의 값들이 `char` 객체에 저장될 경우, 그 동작은 구현 정의에 따른다. 즉, 값들은 부호 있는 정수 또는 음이 아닌 정수로 취급된다.

부호 있는 정수 타입은 네가지 종류가 있으며, `signed char`, `short int`, `int`, `long int`로 지칭된다. (부호 있는 정수 및 기타 타입들은 [3.5.2](#352-타입-지정자)항에 기술된 바와 같이 몇 가지 추가적인 방법으로 지칭될 수 있다.)

`signed char` 타입으로 선언된 객체는 "일반" `char` 객체와 동일한 양의 저장 공간을 차지한다. "일반" `int` 객체는 실행 환경의 아키텍처가 제안하는 자연스러운 크기를 가진다(헤더 `<limits.h>`에 정의된 `INT_MIN`에서 `INT_MAX`까지의 모든 값을 포함할 수 있을 만큼 크다). 위에 나온 부호 있는 정수형 목록에서, 각 타입의 값의 범위는 목록상 다음 타입의 값 범위 안에 속한다.

각 부호 있는 정수 타입에는 그에 대응하는(하지만 서로 다른) 부호 없는 정수 타입이(`unsigned` 키워드로 지정된다) 있는데, 동일한 양의 저장 공간(부호 정보를 포함하여)를 사용하고 동일한 정렬 요구 사항을 가진다. 부호 있는 정수 타입의 음이 아닌 값의 범위는 대응하는 부호 없는 정수 타입 범위 안에 속하며, 두 타입에서 동일한 값에 대한 표현은 같다. 부호 없는 피연산자를 포함하는 연산은 절대 오버플로되지 않는데, 왜냐하면 해당 부호 없는 정수 타입으로 표현될 수 없는 결과는 해당 타입으로 표현할 수 있는 가장 큰 값보다 1 큰 수로 나눈 나머지로 감소하기 때문이다.

실수 타입은 세 가지가 있으며, `float`, `double`, `long double`로 지칭된다. `float` 타입의 값 집합은 `double` 타입 값 집합의 부분 집합이며, `double` 타입의 값 집합은 `long double` 타입 값 집합의 부분 집합이다.

`char` 타입, 부호 있는 및 부호 없는 정수 타입, 실수 타입을 통틀어 기본 타입이라 부릅니다. 구현체가 두 개 이상의 기본 타입을 동일한 표현 방식으로 정의하더라도, 이들은 엄연히 서로 다른 타입이다.

문자 타입에는 세가지 종류가 있으며, `char`, `signed char`, `unsigned char`로 지칭된다.

열거체는 이름이 붙은 정수 상수 값들의 집합으로 구성된다. 각 열거체는 서로 다른 열거 타입을 구성한다.

`void` 타입은 값의 공집합으로 구성되며, 완성될 수 없는 불완전 타입이다.

어떤 횟수의 파생 타입도 기본 타입, 열거 타입, 불완전 타입으로부터 다음과 같이 구성할 수 있다.

* 배열 타입은 원소 타입이라고 하는 특정 멤버 객체 타입이 연속적으로 할당된 집합을 설명한다. 배열 타입은 원소 타입과 배열에 속한 멤버 수에 의해 결정된다. 배열 타입은 그 원소 타입으로부터 파생되었다고 하며, 원소 타입이 `T`라면 배열형은 가끔 "`T`의 배열"이라고도 불린다. 원소 타입으로부터 배열 타입을 만드는 것을 "배열 타입 파생"이라고 한다.

* 구조체 타입은 순서대로 할당된 멤버 객체들의 집합을 설명하며, 각 멤버는 선택적으로 이름이 지정될 수 있고, 각 멤버의 타입은 달라도 된다.

* 공용체 타입은 겹치는 멤버 객체들의 집합을 설명하며, 각 멤버는 선택적으로 이름이 지정될 수 있고, 각 멤버의 타입은 달라도 된다.

* 함수 타입은 특정 반환 타입이 정해진 함수를 설명한다. 함수 타입은 반환 타입과 매개변수들의 개수 및 타입들로 결정된다. 함수 타입은 그것의 반환 타입으로부터 파생되었다고 하며, 반환 타입이 `T`라면 함수형은 가끔 "`T`를 반환하는 함수"라고 불린다. 반환 타입으로부터 함수 타입을 만드는 것을 "함수 타입 파생"이라고 한다.

* 포인터 타입은 참조되는 타입이라고 불리는 함수 타입, 객체 타입, 불완전 타입으로부터 파생될 수 있다. 포인터 타입은 참조되는 타입 개체에 대한 참조를 제공하는 값을 가진 객체를 설명한다. 참조되는 타입 `T`로부터 파생된 포인터 타입은 가끔 "`T`에 대한 포인터"라고 불린다. 참조되는 타입으로부터 포인터 타입을 만드는 것을 "포인터 타입 파생"이라고 한다.

이러한 파생 타입을 만드는 방법은 재귀적으로 적용될 수 있다.

`char` 타입, 부호 있는 및 부호 없는 정수 타입, 그리고 열거 타입을 통틀어 정수 계열이라고 부른다. 정수 계열의 표현은 순수 이진법을 사용하여 값을 정의해야 한다. ([^13] 미국 국립 정보 처리 시스템 사전.) 실수 타입의 표현 방식은 명시하지 않는다.

정수 계열 타입과 실수 타입을 통틀어 산술 타입이라 부른다. 산술 타입과 포인터 타입을 통틀어 스칼라 타입이라 부른다. 배열 타입과 구조체 타입을 통틀어 묶음 타입이라 부른다. [^14]

`void`에 대한 포인터는 문자 타입에 대한 포인터와 동일한 표현 및 정렬 요구 사항을 가져야 한다. 그 외의 포인터 타입들은 동일한 표현이나 정렬 요구 사항을 가질 필요가 없다.

크기를 알 수 없는 배열 타입은 불완전 타입이다. 나중에 같은 타입의 해당 식별자에 대한 선언(내부 또는 외부 연결을 가지는)에서 크기를 지정함으로써 해당 타입이 완성된다. 내용을 알 수 없는 구조체 또는 공용체 타입([3.5.2.3](#3523-태그)에 기술된 바와 같이)는 불완전 타입이다. 동일한 유효 범위에서 나중에 내용 정의를 포함하여 동일한 구조체 또는 공용체 태그를 선언함으로써 해당 타입이 완성됩니다.

배열 타입, 함수 타입, 포인터 타입을 통틀어 파생된 선언자 타입이라 부른다. 타입 `T`로부터의 선언자 타입 파생은 `T`에 배열, 함수, 또는 포인터 타입 파생을 적용하여 `T`로부터 파생된 선언자 타입을 만드는 것이다.

타입은 대표 타입에 의해 특징지어진다. 대표 타입은 파생된 타입을 설명할 때 가장 먼저 정해진 타입이거나(앞에서 파생된 타입 구성에서 언급된 것처럼), 타입이 파생되지 않은 경우에는 그 타입 자체가 된다.

대표 타입에 타입 한정자가 지정된 경우 해당 타입은 한정된 타입을 갖습니다. 그렇지 않으면 비한정 타입을 갖는다. 타입 한정자 `const`와 `volatile`은 각각 const-한정된 타입과 volatile-한정된 타입을 지정한다.[^15] 각각의 한정된 타입에 대해, 한정된 타입과 동일한 방식으로 지정되지만 대표 타입에 타입 한정자가 없는 비한정 타입이 존재하며, 이 타입을 한정된 타입의 비한정 버전이라고 한다. 마찬가지로, 적절하게 한정된 버전의 타입(타입의 const-한정 버전처럼)이 존재하며, 적절하게 한정되지 않은 버전의 타입(타입의 non-const-한정 버전처럼)도 존재한다.

###### 예제

"`float *`"로 지정된 타입은 "`float`에 대한 포인터"라고 불리며, 대표 타입은 실수 타입이 아니라 포인터 타입이다. 해당 타입의 const-한정 버전은 "`float * const`"로 지정되는 반면, "`const float *`"로 지정된 타입은 한정된 타입이 아니다 --- "`const float`에 대한 포인터"라고 불리며, 한정된 타입에 대한 포인터다.

마지막으로, "`struct tag (*[5])(float)`"로 지정된 타입은 "`struct tag`를 반환하는 함수에 대한 포인터의 배열"이라고 불린다. 여기서 대표 타입은 배열 타입이다. 배열의 길이는 `5`이며, 함수는 `float` 타입의 단일 매개변수를 갖는다.

**전방 참조**: 문자 상수 ([3.1.3.4](#3134-문자-상수)), 선언 ([3.5](#35-선언)), 태그 ([3.5.2.3](#3523-태그)), 타입 한정자 ([3.5.3](#353-타입-한정자)).

##### 3.1.2.6 호환 타입과 합성 타입

두 타입이 동일하다면, 그 둘은 호환되는 타입을 갖는다. 두 타입의 호환 여부를 결정하는 추가적인 규칙은 [3.5.2](#352-타입-지정자)에서 타입 지정자에 대해, [3.5.3](#353-타입-한정자)에서 타입 한정자에 대해, [3.5.4](#354-선언자)에서 선언자에 대해 기술되어 있다.[^16] 더 나아가, 서로 다른 변환 단위에서 선언된 두 구조체, 공용체, 또는 열거 타입이 호환되려면, 멤버의 수가 같고, 멤버의 이름이 같고, 멤버들의 타입이 호환되어야 한다. 단, 두 구조체의 경우 멤버들의 순서가 같아야 하며, 두 열거 타입의 경우 멤버들의 값이 같아야 한다.

동일한 객체나 함수를 의미하는 모든 선언은 호환되는 타입을 가져야 합니다. 그렇지 않을 경우 그 동작은 정의되지 않는다.

호환되는 두 타입으로부터 합성 타입을 구성할 수 있는데, 이는 두 타입 모두와 호환되면서 다음의 추가 사항을 갖는 타입이다.

* 한 타입이 크기가 알려진 배열이라면, 합성 타입은 그 크기를 가진 배열입니다.

* 한 타입만이 매개변수 타입 목록을 가진 함수 타입(함수 원형)이라면, 합성 타입은 해당 매개변수 타입 목록을 가진 함수 원형이 된다.

* 두 타입 모두 매개변수 타입 목록을 가지고 있다면, 합성된 매개변수 목록의 각 매개변수 타입은 대응하는 매개변수들의 합성 타입이 된다.

이 규칙들은 두 타입이 파생된 원본 타입들에도 재귀적으로 적용된다.

외부 또는 내부 연결을 갖는 식별자가 해당 식별자에 대한 다른 선언과 동일한 유효 범위에서 선언된 경우, 그 식별자의 타입은 합성 타입이 된다.

###### 예제

파일 범위 선언 두개가 다음과 같이 주어졌을 때:

```c
         int f(int (*)(), double (*)[3]);
         int f(int (*)(char *), double (*)[]);
```

결과적으로 생성되는 함수의 합성 타입은 다음과 같다:

```c
         int f(int (*)(char *), double (*)[3]);
```

**전방 참조**: 선언자 ([3.5.4](#354-선언자)), 열거 타입 지정자 ([3.5.2.2](#3522-열거체-지정자)), 구조체 및 공용체 지정자 ([3.5.2.1](#3521-구조체-및-공용체-지정자)), 타입 정의 ([3.5.6](#356-타입-정의)), 타입 한정자 ([3.5.3](#353-타입-한정자)), 타입 지정자 ([3.5.2](#352-타입-지정자)).

#### 3.1.3 상수

###### 문법

<a name="상수"></a>
*상수:*
>
> [*실수-상수*](#실수-상수)
>
> [*정수-상수*](#정수-상수)
>
> [*열거-상수*](#열거-상수)
>
> [*문자-상수*](#문자-상수)
>
###### 제약

상수의 값은 그 타입으로 표현 가능한 값의 범위 안에 있어야 한다.

###### 의미

각 상수는 타입을 가지며, 그 타입은 상수의 형태와 값에 의해 결정된다. 자세한 내용은 뒤에서 설명한다.

##### 3.1.3.1 실수 상수

###### 문법

<a name="실수-상수"></a>
*실수-상수:*
>
> [*소수점-상수*](#소수점-상수) &nbsp; *[지수부](#지수부)<sub>옵션</sub>* &nbsp; *[실수-접미어](#실수-접미어)<sub>옵션</sub>*
>
> [*숫자열*](#숫자열) &nbsp; [*지수부*](#지수부) &nbsp; *[실수-접미어](#실수-접미어)<sub>옵션</sub>*
>
<a name="소수점-상수"></a>
*소수점-상수:*
>
> *[숫자열](#숫자열)<sub>옵션</sub>* &nbsp; **.** &nbsp; [*숫자열*](#숫자열)
>
> [*숫자열*](#숫자열) &nbsp; **.**
>
<a name="지수부"></a>
*지수부:*
>
> **e** &nbsp; *[부호](#부호)<sub>옵션</sub>* &nbsp; [*숫자열*](#숫자열)
>
> **E** &nbsp; *[부호](#부호)<sub>옵션</sub>* &nbsp; [*숫자열*](#숫자열)
>
<a name="부호"></a>
*부호:* <sub>다음 중 하나</sub>
>
> **+** **-**
>
<a name="숫자열"></a>
*숫자열:*
>
> [*숫자*](#숫자)
>
> [*숫자열*](#숫자열) &nbsp; [*숫자*](#숫자)
>
<a name="실수-접미어"></a>
*실수-접미어:* <sub>다음 중 하나</sub>
> 
> **f** **l** **F** **L**
>
###### 설명

실수 상수는 값 부분을 가지며, 그 뒤에 지수 부분과 타입을 지정하는 접미어가 뒤따를 수 있다. 값 부분의 구성요소로 포함될 수 있는 것은, 정수부를 나타내는 숫자열, 그 뒤에 마침표(`.`), 그 뒤에 소수부를 나타내는 숫자열이다. 지수 부분의 구성요소는 `e` 또는 `E`와 그 뒤의 숫자열이다(숫자열에 부호가 붙을 수도 있다). 정수부 또는 소수부 중 적어도 하나는 반드시 존재해야 하며, 또한 마침표 또는 지수 부분 중 적어도 하나는 반드시 존재해야 한다.

###### 의미

값 부분은 10진 유리수로 해석되며, 지수 부분의 숫자열은 10진 정수로 해석된다. 지수는 값 부분에 곱해질 10의 거듭제곱을 나타낸다. 스케일된 값이 (해당 타입에서) 표현 가능한 값의 범위 안에 있지만 정확하게 표현될 수 없는 경우, 결과는 가장 가까운 더 큰 값 또는 가장 가까운 더 작은 값 중 하나가 되며, 어느 쪽을 선택하는지는 구현 정의 방식으로 결정된다.

접미어가 없는 실수 상수의 타입은 `double`이다. 문자 `f` 또는 `F`가 접미어로 붙으면 타입은 `float`이다. 문자 `l` 또는 `L`이 접미어로 붙으면 타입은 `long double`이다.

##### 3.1.3.2 정수 상수

###### 문법

<a name="정수-상수"></a>
*정수-상수:*
>
> [*십진-상수*](#십진-상수) &nbsp; *[정수-접미어](#정수-접미어)<sub>옵션</sub>*
>
> [*팔진-상수*](#팔진-상수) &nbsp; *[정수-접미어](#정수-접미어)<sub>옵션</sub>*
>
> [*십육진-상수*](#십육진-상수) &nbsp; *[정수-접미어](#정수-접미어)<sub>옵션</sub>*
>
<a name="십진-상수"></a>
*십진-상수:*
>
> [*영이아닌-숫자*](#영이아닌-숫자)
>
> [*십진-상수*](#십진-상수) &nbsp; [*숫자*](#숫자)
>
<a name="팔진-상수"></a>
*팔진-상수:*
>
> **0**
>
> [*팔진-상수*](#팔진-상수) &nbsp; [*팔진-숫자*](#팔진-숫자)
>
<a name="십육진-상수"></a>
*십육진-상수:*
>
> **0x** &nbsp; [*십육진-숫자*](#십육진-숫자)
>
> **0X** &nbsp; [*십육진-숫자*](#십육진-숫자)
>
> [*십육진-상수*](#십육진-상수) &nbsp; [*십육진-숫자*](#십육진-숫자)
>
<a name="영이아닌-숫자"></a>
*영이아닌-숫자:* <sub>one of</sub>
> 
> **1** **2** **3** **4** **5** **6** **7** **8** **9** 
> 
<a name="팔진-숫자"></a>
*팔진-숫자:* <sub>one of</sub>
> 
> **0** **1** **2** **3** **4** **5** **6** **7**
> 
<a name="십육진-숫자"></a>
*십육진-숫자:* <sub>다음 중 하나</sub>
> 
> **0** **1** **2** **3** **4** **5** **6** **7** **8** **9** 
> 
> **a** **b** **c** **d** **e** **f**
> 
> **A** **B** **C** **D** **E** **F**
>
<a name="정수-접미어"></a>
*정수-접미어:*
>
> [*unsigned-접미어*](#unsigned-접미어) &nbsp; *[long-접미어](#long-접미어)<sub>옵션</sub>*
>
> [*long-접미어*](#long-접미어) &nbsp; *[unsigned-접미어](#unsigned-접미어)<sub>옵션</sub>*
>
<a name="unsigned-접미어"></a>
*unsigned-접미어:* <sub>다음 중 하나</sub>
>
> **u** **U**
>
<a name="long-접미어"></a>
*long-접미어:* <sub>다음 중 하나</sub>
> 
> **l** **L**
> 
###### 설명

정수 상수는 숫자로 시작하지만, 마침표나 지수 부분을 갖지 않는다. 정수 상수는 기수를 정하는 접두어와 타입을 정하는 접미어를 가질 수 있다.

10진 상수는 0이 아닌 숫자로 시작하며, 연속된 10진 숫자들로 이루어진다. 8진 상수는 접두어 `0`으로 시작하고, 그 뒤에 선택적으로 `0`부터 `7`까지만으로만 이루어진 숫자열이 올 수 있다. 16진 상수는 접두어 `0x` 또는 `0X`로 시작하고, 그 뒤에 10진 숫자와 문자 `a`(또는 `A`)부터 `f`(또는 `F`)까지로 이루어진 숫자열이 오며, 여기서 각 문자들은 10부터 15 까지의 값을 갖는다.

###### 의미

10진 상수의 값은 10진수로 계산되며, 8진 상수는 8진수, 16진 상수는 16진수로 계산된다. 어휘적으로 가장 먼저 오는 첫 번째 숫자가 가장 큰 자리수가 된다.

정수 상수의 타입은, 해당하는 목록에서 그 값이 표현될 수 있는 타입들 중 가장 왼쪽에 있는 것이다. 접미어가 없는 10진 상수: `int`, `long int`, `unsigned long int`; 접미사가 없는 8진 또는 16진 상수: `int`, `unsigned int`, `long int`, `unsigned long int`; 접미어로 `u` 또는 `U`가 붙은 경우: `unsigned int`, `unsigned long int`, 접미어로 `l` 또는 `L`이 붙은 경우: `long int`, `unsigned long int`, 접미어로 `u` 또는 `U`와 `l` 또는 `L`이 모두 붙은 경우: `unsigned long int`

##### 3.1.3.3 열거 상수

##### 3.1.3.3 Enumeration constants

###### 문법

<a name="열거-상수"></a>
*열거-상수:*
> 
> [*식별자*](#식별자)
> 
###### 의미

열거 상수로 선언된 식별자는 `int` 타입을 갖는다.

**전방 참조**: 열거체 지정자 ([3.5.2.2](#3522-열거체-지정자)).

##### 3.1.3.4 문자 상수

###### 문법

<a name="문자-상수"></a>
*문자-상수:*
>
> **'** &nbsp; [*c-문자-시퀀스*](#c-문자-시퀀스) &nbsp; **'**
>
> **L** &nbsp; **'** &nbsp; [*c-문자-시퀀스*](#c-문자-시퀀스) &nbsp; **'**
>
<a name="c-문자-시퀀스"></a>
*c-문자-시퀀스:*
>
> [*c-문자*](#c-문자)
>
> [*c-문자-시퀀스*](#c-문자-시퀀스) &nbsp; [*c-문자*](#c-문자)
>
<a name="c-문자"></a>
*c-문자:*
> 
> <sub>**작은따옴표 ', 역슬래시 \, 또는 개행 문자를 제외한 소스 문자 집합의 모든 원소**</sub>
> 
> [*이스케이프-시퀀스*](#이스케이프-시퀀스)
> 
<a name="이스케이프-시퀀스"></a>
*이스케이프-시퀀스:*
>
> [*단순-이스케이프-시퀀스*](#단순-이스케이프-시퀀스)
>
> [*팔진-이스케이프-시퀀스*](#팔진-이스케이프-시퀀스)
>
> [*십육진-이스케이프-시퀀스*](#십육진-이스케이프-시퀀스)
>
<a name="단순-이스케이프-시퀀스"></a>
*단순-이스케이프-시퀀스:* <sub>다음 중 하나</sub>
> 
> **\'** **\"** **\?** **\\**
> 
> **\a** **\b** **\f** **\n** **\r** **\t** **\v**
> 
<a name="팔진-이스케이프-시퀀스"></a>
*팔진-이스케이프-시퀀스:* 
>
> **\** &nbsp; [*팔진-숫자*](#팔진-숫자)
>
> **\** &nbsp; [*팔진-숫자*](#팔진-숫자) &nbsp; [*팔진-숫자*](#팔진-숫자)
>
> **\** &nbsp; [*팔진-숫자*](#팔진-숫자) &nbsp; [*팔진-숫자*](#팔진-숫자) &nbsp; [*팔진-숫자*](#팔진-숫자)
>
<a name="십육진-숫자"></a>
*십육진-숫자:* 
>
> **\x** &nbsp; [*십육진-숫자*](#십육진-숫자)
>
> [*십육진-이스케이프-시퀀스*](#십육진-이스케이프-시퀀스) &nbsp; [*십육진-숫자*](#십육진-숫자)
>
###### 설명

정수 문자 상수는 `'x'` 또는 `'ab'`와 같이 작은따옴표로 묶인 하나 이상의 멀티바이트 문자 시퀀스다. 와이드 문자 상수는 동일한 형태를 가지지만 문자 `L`이 접두어로 붙는다. 뒤에서 설명할 몇 가지 예외를 제외하고, 시퀀스의 각 문자는 소스 문자 집합의 어떤 원소든 될 수 있으며, 구현 정의 방식에 따라 실행 문자 집합의 원소로 매핑된다.

작은따옴표 `'`, 큰따옴표 `"`, 물음표 `?`, 역슬래시 `\` 및 임의의 정수 값들은 다음 이스케이프 시퀀스 표에 따라 표현 가능합니다:

|   |   |   |
| :--- | :----- | :----- |
| 작은따옴표 | \' | `\'` |
| 큰따옴표 | \" | `\"` |
| 물음표 | \? | `\?` |
| 역슬래시 | \\ | `\\` |
| 8진 정수 |   | `\` 8진 숫자 |
| 16진 정수 |   | `\x` 16진 숫자 |

큰따옴표 `"`와 물음표 `?`는 그 자체로 쓰이거나 각각 이스케이프 시퀀스 `\"`와 `\?`로 표현될 수 있지만, 작은따옴표 `'`와 역슬래시 `\`는 반드시 각각 이스케이프 시퀀스 `\'`와 `\\`로 표현되어야 한다.

8진 이스케이프 시퀀스의 역슬래시 뒤에 오는 8진수 숫자는 정수 문자 상수나 와이드 문자 상수의 단일 문자를 구성하는 데 사용됩니다. 이렇게 형성된 8진수 정수의 수치값이 원하는 문자의 값을 지정합니다.

8진 이스케이프 시퀀스에서 역슬래시 뒤에 오는 8진 숫자들은, 정수 문자 상수의 경우 하나의 문자를, 와이드 문자 상수의 경우 하나의 와이드 문자를 구성하는 일부로 간주된다. 그렇게 정해진 8진 정수의 숫자 값이 원하는 문자 값을 정한다.

16진 이스케이프 시퀀스에서 역슬래시와 문자 `x` 뒤에 오는 16진 숫자들도, 정수 문자 상수의 경우 하나의 문자를, 와이드 문자 상수의 경우 하나의 와이드 문자를 구성하는 일부로 간주된다. 그렇게 정해진 16진 정수의 숫자 값이 원하는 문자 값을 정한다.

각 8진 또는 16진 이스케이프 시퀀스는, 그 이스케이프 시퀀스를 구성할 수 있는 문자들의 가장 긴 시퀀스로 해석된다.

또한, 특정 비그래픽 문자들은 역슬래시 `\` 뒤에 알파벳 소문자를 붙인 이스케이프 시퀀스로 표현할 수 있다: `\a`, `\b`, `\f`, `\n`, `\r`, `\t`, `\v`.[^17] 그 밖의 다른 이스케이프 시퀀스를 만나면, 동작은 정의되지 않는다.[^18]

###### 제약

8진 또는 16진 이스케이프 시퀀스의 값은, 그 타입에 대응하는 `unsigned` 타입이 표현할 수 있는 값의 범위 안에 있어야 한다.

###### 의미

정수 문자 상수는 타입이 `int`다. 단일 문자로 구성된 정수 문자 상수 중에 기본 실행 문자 집합의 구성원으로 매핑되는 정수 문자 상수의 값은, 매핑된 문자를 표현하는 숫자 값을 정수로 해석한 것이다. 두 개 이상의 문자로 구성된 정수 문자 상수의 값, 또는 기본 실행 문자 집합으로 표현되지 않는 문자나 이스케이프 시퀀스를 포함하는 정수 문자 상수의 값은 구현 정의이다. 특히, `char` 타입이 `signed char`와 동일한 값의 범위를 갖는 구현에서는, 단일 문자로 이루어진 정수 문자 상수의 가장 큰 비트 위치가 부호 비트로 취급된다.

와이드 문자 상수는 `<stddef.h>` 헤더에 정의된 정수 계열 타입인 `wchar_t` 타입을 가진다. 단일 다중바이트 문자로 구성된 와이드 문자 상수 중에 확장 실행 문자 집합의 구성원으로 매핑되는 와이드 문자 상수의 값은, 매핑된 다중바이트 문자에 해당하는 와이드 문자 (코드)로, 구현 정의된 현재 로케일에서 `mbtowc` 함수가 정의하는 바에 따른다. 두 개 이상의 다중바이트 문자로 구성된 와이드 문자 상수의 값, 또는 확장 실행 문자 집합으로 표현되지 않는 다중바이트 문자나 이스케이프 시퀀스를 포함하는 와이드 문자 상수의 값은 구현 정의이다.

###### 예제

`'\0'` 표기는 null 문자를 나타내는 데 흔히 사용된다.

정수를 2의 보수로 표현하고, `char` 타입 객체에 8비트를 사용하는 구현들을 생각해보자. `char` 타입이 `signed char`와 같은 값의 범위를 갖는 구현에서는 정수 문자 상수 `'\xFF'`의 값이 -1이다. `char` 타입이 `unsigned char`와 같은 값의 범위를 갖는 구현에서는 문자 상수 `'\xFF'`의 값이 `255`이다.

`char` 타입 객체에 8비트를 사용하더라도, 표기 `'\x123'`는 오직 한 개의 문자만을 포함하는 정수 문자 상수를 지정한다. (이 단일 문자 정수 문자 상수의 값은 구현 정의이며 위의 제약을 위반한다.) 값이 `0x12`와 '3'인 두 문자를 포함하는 정수 문자 상수를 지정하려면, 16진 이스케이프 시퀀스는 16진수가 아닌 문자에 의해서만 종료되므로 '\0223'를 사용할 수 있다. (이 두 문자 정수 문자 상수의 값도 구현 정의이다.)

`wchar_t` 타입 객체에 12비트 이상을 사용하더라도, 표기 `L'\1234'`는 값 `0123`과 `'4'`의 조합 결과로 얻어지는 구현 정의 값을 지정한다.

**전방 참조**: 문자와 정수 ([3.2.1.1](#3211-문자와-정수)), 공통 정의 <stddef.h> ([4.1.5](#415-공통-정의-stddefh)), mbtowc 함수 ([4.10.7.2](#41072-mbtowc-함수)).

#### 3.1.4 문자열 리터럴

###### 문법

<a name="문자열-리터럴"></a>
*문자열-리터럴:*
>
> **"** &nbsp; *[s-문자-시퀀스](#s-문자-시퀀스)<sub>옵션</sub>* &nbsp; **"**
>
> **L** &nbsp; **"** &nbsp; *[s-문자-시퀀스](#s-문자-시퀀스)<sub>옵션</sub>* &nbsp; **"**
>
<a name="s-문자-시퀀스"></a>
*s-문자-시퀀스:*
>
> [*s-문자*](#s-문자)
>
> [*s-문자-시퀀스*](#s-문자-시퀀스) &nbsp; [*s-문자*](#s-문자)
>
<a name="s-문자"></a>
*s-문자:*
> 
> <sub>**큰따옴표 ", 역슬래시 \, 또는 개행 문자를 제외한 소스 문자 집합의 모든 원소**</sub>
> 
> [*이스케이프-시퀀스*](#이스케이프-시퀀스)
> 
###### 설명

문자열 리터럴은 `"xyz"`와 같이 큰따옴표로 묶인 0개 이상의 멀티바이트 문자 시퀀스다. 와이드 문자열 리터럴은 문자 `L`이 접두어로 붙는다는 점을 제외하면 동일하다.

문자열 리터럴이나 와이드 문자열 리터럴 시퀀스의 각 요소에는, 정수 문자 상수나 와이드 문자 상수에 적용되는 것과 동일한 고려 사항이 적용되는데, 한가지 예외로, 작은따옴표 `'`는 그 자체로 또는 이스케이프 시퀀스 `\'`로 표현할 수 있지만, 큰따옴표는 반드시 이스케이프 시퀀스 `\"`로 표현되어야 한다.

###### 의미

문자열 리터럴은 정적 저장 기간을 가지며 타입은 "`char`의 배열"이고, 주어진 문자들로 초기화된다. 와이드 문자열 리터럴은 정적 저장 기간을 가지며 타입은 "`wchar_t`의 배열"이고, 주어진 다중바이트 문자들에 대응하는 와이드 문자들로 초기화된다. 서로 인접한 문자열 리터럴 토큰들은 하나의 문자열 리터럴로 연결된다. 그 다음 null 문자가 뒤에 추가된다.[^19] 마찬가지로, 서로 인접한 와이드 문자열 리터럴 토큰들도 하나의 와이드 문자열 리터럴로 연결되며, 그 뒤에 값이 0인 코드가 추가된다. 문자열 리터럴 토큰이 와이드 문자열 리터럴 토큰과 인접해 있는 경우, 동작은 정의되지 않는다.

두 형태 중 어느 쪽이든, 동일한 문자열 리터럴들이 서로 다른 객체일 필요는 없다. 프로그램이 어느 형태의 문자열 리터럴이든 수정하려고 시도하면, 동작은 정의되지 않는다.

###### 예제

다음과 같이 인접한 두 문자열 리터럴
```c
         "\x12" "3"
```
은, 값이 `\x12`와 `'3'`인 두 문자를 포함하는 하나의 문자열 리터럴을 생성한다. 그 이유는 이스케이프 시퀀스가 인접 문자열 리터럴 연결 직전에 실행 문자 집합의 단일 구성원으로 변환되기 때문이다.

**전방 참조**: 공통 정의 <stddef.h> ([4.1.5](#415-공통-정의-stddefh)).

#### 3.1.5 연산자

###### 문법

<a name="연산자"></a>
*연산자:* <sub>다음 중 하나</sub>
> 
> **\[** &nbsp; **\]** &nbsp; **(** &nbsp; **)** &nbsp; **.** &nbsp; **->**
> 
> **++** &nbsp; **--** &nbsp; **&** &nbsp; **\*** &nbsp; **+** &nbsp; **-** &nbsp; **~** &nbsp; **!** &nbsp; **sizeof**
> 
> **/** &nbsp; **%** &nbsp; **<<** &nbsp; **>>** &nbsp; **<** &nbsp; **>** &nbsp; **<=** &nbsp; **>=** &nbsp; **==** &nbsp; **!=** &nbsp; **^** &nbsp; **|** &nbsp; **&&** &nbsp; **||** &nbsp; **?** &nbsp; **:**
> 
> **=** &nbsp; **\*=** &nbsp; **/=** &nbsp; **%=** &nbsp; **+=** &nbsp; **-=** &nbsp; **<<=** &nbsp; **>>=** &nbsp; **&=** &nbsp; **^=** &nbsp; **|=** &nbsp; **,** &nbsp; **#** &nbsp; **##**
> 
###### 제약

연산자 `[ ]`, `( )`, `? :`는 쌍으로 나타나야 하며, 그 사이에 수식이 위치할 수 있다. 연산자 `#` 및 `##`는 매크로를 정의하는 전처리 지시문에서만 나타나야 한다.

###### 의미

연산자는 어떤 연산을 수행할지(평가)를 정하는데, 연산은 값을 구하거나, 지정자를 얻거나, 부수 효과를 발생시키거나, 이들의 조합을 수행한다. 피연산자는 연산자가 작용하는 대상이다.

**전방 참조**: 수식 ([3.3](#33-수식)), 매크로 치환 ([3.8.3](#383-매크로-치환)).

#### 3.1.6 구두점

###### 문법

<a name="구두점"></a>
*구두점:* <sub>다음 중 하나</sub>
> 
> **\[** &nbsp; **\]** &nbsp; **(** &nbsp; **)** &nbsp; **{** &nbsp; **}** &nbsp; **\*** &nbsp; **,** &nbsp; **:** &nbsp; **=** &nbsp; **;** &nbsp; **...** &nbsp; **#**
>
###### 제약

구두점 `[ ]`, `( )`, `{ }` 는 쌍으로 나타나야 하며, 그 사이에 수식, 선언, 문장이 올 수 있다. 구두점 `#`은 전처리 지시문에서만 나타나야 한다.

###### 의미

구두점은 독립적인 구문적, 의미적 중요성을 갖지 기호지만, 값을 산출하는 연산을 지정하지는 않는다. 문맥에 따라, 동일한 기호가 연산자나 연산자의 일부를 나타낼 수도 있다.

**Forward references**: 수식 ([3.3](#33-수식)), 선언 ([3.5](#35-선언)), 전처리 지시문 ([3.8](#38-전처리-지시문)), 문장 ([3.6](#36-문장)).

#### 3.1.7 헤더 이름

###### 문법

<a name="헤더-이름"></a>
*헤더-이름:*
>
> **<** &nbsp; [*h-문자-시퀀스*](#h-문자-시퀀스) &nbsp; **>**
>
> **"** &nbsp; [*q-문자-시퀀스*](#q-문자-시퀀스) &nbsp; **"**
>
<a name="h-문자-시퀀스"></a>
*h-문자-시퀀스:*
>
> [*h-문자*](#h-문자)
>
> [*h-문자-시퀀스*](#h-문자-시퀀스) &nbsp; [*h-문자*](#h-문자)
>
<a name="h-문자"></a>
*h-문자:*
> 
> <sub>**개행 문자와 >를 제외한 소스 문자 집합의 모든 원소**</sub>
> 
<a name="q-문자-시퀀스"></a>
*q-문자-시퀀스:*
>
> [*q-문자*](#q-문자)
>
> [*q-문자-시퀀스*](#q-문자-시퀀스) &nbsp; [*q-문자*](#q-문자)
>
<a name="q-문자"></a>
*q-문자:*
> 
> <sub>**개행 문자와 "를 제외한 소스 문자 집합의 모든 원소**</sub>
> 
###### 제약

헤더 이름 전처리 토큰은 오직 `#include` 전처리 지시문 안에서만 나타나야 한다.

###### 의미

두 가지 형태의 헤더 이름에 있는 시퀀스는 [3.8.2](#382-소스-파일-포함)절에 명시된 대로 구현 정의된 방식에 따라 헤더나 외부 소스 파일 이름으로 매핑된다.

만약 `<` 와 `>` 구분자 사이의 시퀀스에 문자 `'`, `\`, `"`, `/*`가 나타난다면, 그 동작은 정의되지 않는다. 마찬가지로, 만약 `"` 구분자 사이의 시퀀스에 문자 `'`, `\`, `/*`가 나타난다면, 그 동작은 정의되지 않는다.[^20]

###### 예제

다음 문자 시퀀스는:

```c
         0x3<1/a.h>1e2
         #include <1/a.h>
         #define const.member@$
```

다음의 전처리 토큰 시퀀스를 형성한다 (각각의 개별 전처리 토큰은 왼쪽의 `{`와 오른쪽의 `}`로 구분된다).

```
         {0x3}{<}{1}{/}{a}{.}{h}{>}{1e2}
         {#}{include} {<1/a.h>}
         {#}{define} {const}{.}{member}{@}{$}
```

**전방 참조**: 소스 파일 포함 ([3.8.2](#382-소스-파일-포함)).

#### 3.1.8 전처리 숫자

###### 문법

<a name="전처리-숫자"></a>
*전처리-숫자:*
>
> [*숫자*](#숫자)
>
> **.** &nbsp; [*숫자*](#숫자)
>
> [*전처리-숫자*](#전처리-숫자) &nbsp; [*숫자*](#숫자)
>
> [*전처리-숫자*](#전처리-숫자) &nbsp; [*비숫자*](#비숫자)
>
> [*전처리-숫자*](#전처리-숫자) &nbsp; **e** &nbsp; [*부호*](#부호)
>
> [*전처리-숫자*](#전처리-숫자) &nbsp; **E** &nbsp; [*부호*](#부호)
>
> [*전처리-숫자*](#전처리-숫자) &nbsp; **.**
>
###### 설명

전처리 숫자는 숫자로 시작하거나, 선택적으로 그 앞에 마침표가 붙고, 그 뒤에 문자, 밑줄, 숫자, 마침표, 그리고 `e+`, `e-`, `E+`, `E-` 문자 시퀀스가 올 수 있다.

전처리 숫자 토큰은 어휘적으로 모든 실수 상수 토큰과 정수 상수 토큰을 포함한다.

###### 의미

전처리 숫자는 타입이나 값을 갖지 않으며, (번역 단계 7의 일부로서) 실수 상수 토큰 또는 정수 상수 토큰으로 성공적으로 변환된 이후에야 타입과 값을 갖게 된다.

#### 3.1.9 주석

문자 상수, 문자열 리터럴, 주석 내부에서를 제외하면, 문자 `/*`는 주석을 시작한다. 주석의 내용은 오직 멀티바이트 문자를 식별하거나 주석을 종료하는 문자 `*/`를 찾기 위해서만 검사된다.[^21]

### 3.2 변환

### 3.2 타입 변환

많은 연산자들이 피연산자의 값을 한 타입에서 다른 타입으로 자동으로 변환한다. 본 섹션은 이러한 자동 변환과 캐스트 연산에 의한 직접 변환에서 요구되는 결과를 정한다. 대부분의 평범한 연산자들이 하는 타입 변환의 목록은 [3.2.1.5](#3215-일반-산술-변환)에 요약되어 있으며, 이는 [3.3](#33-수식)에 있는 각 연산자에 대한 논의에서 요구하는 바에 의해 보완된다.

피연산자 값을 호환가능 타입으로 변환하는 것은 아무것도 바꾸지 않는다.

**전방 참조**: 캐스트 연산자 ([3.3.4](#334-타입-변환-연산자)).

#### 3.2.1 산술 피연산자

##### 3.2.1.1 문자와 정수

`char`, `short int`, `int` 비트 필드, 그리고 이들의 `signed` 또는 `unsigned` 버전, 혹은 열거 타입 객체는, `int`나 `unsigned int`가 쓰일 수 있는 모든 수식에서 사용 가능하다. 해당 타입의 모든 값이 `int`로 표현 가능한 경우에는, 값이 `int`로 변환되고, 그 외의 경우에는 `unsigned int`로 변환된다. 정수 승격이라는 단어로 이 과정을 부른다. 

정수 승격은 값과 부호를 모두 보존한다. 전에 논의한 것처럼, `char`가 `signed`로 취급될 것인가는 구현에서 정의할 내용이다. 

**전방 참조**: 열거체 지정자 ([3.5.2.2](#3522-열거체-지정자)), 구조체 및 공용체 지정자 ([3.5.2.1](#3521-구조체-및-공용체-지정자)).

##### 3.2.1.2 부호 있는 정수와 부호 없는 정수

부호 없는 정수가 다른 정수 계열 타입으로 변환될 때, 만약 값을 변환될 타입으로 표현할 수 있으면, 값이 변하지 않는다. 

부호 있는 정수가 같은 크기나 더 큰 크기의 부호 없는 정수로 변환될 때, 만약 값이 음이 아니면, 변환 후에 변하지 않는다. 그 외에: 더 큰 크기의 부호 없는 정수로 변환될 때, 값은 먼저 같은 크기의 부호 있는 정수로 변환되고; 그 다음에 부호 없는 정수로 표현 가능한 가장 큰 값보다 하나 더 큰 값이 더해져서 최종적으로 `unsigned`로 변환된다.[^22]

정수가 더 작은 크기의 부호 없는 정수로 강등될 때, 그 결과는 그 작은 크기의 부호 없는 정수로 표현 가능한 최대값에 하나를 더한 숫자로 나눈 음이 아닌 나머지가 된다. 정수가 더 작은 크기의 부호 있는 정수로 강등되거나, 부호 없는 정수가 같은 크기에 해당하는 부호 있는 정수로 변환될 때, 만약 변환할 값이 새로운 타입으로 표현할 수 없다면, 그 결과는 구현에서 정의된다. 

##### 3.2.1.3 실수과 정수

실수 타입의 값을 정수 계열로 변환할 때, 소수 부분은 버려진다. 만약 정수 부분의 값이 장수 계열 타입으로 표현할 수 없다면, 동작은 정의되지 않는다.[^23]

정수 계열 타입의 값이 실수 타입으로 변환될 때, 만약 변환하고 있는 값이 표현될 수는 있지만 정확히 표현될 수 없다면, 그 결과는 표현 가능한 가장 가까운 큰 값 또는 가장 가까운 작은 값이 되며, 그 중 어떤 값을 선택할지는 구현에서 정한 방식을 따른다. 

##### 3.2.1.4 실수 타입

`float`가 `double`이나 `long double`로 승격되거나, `double`이 `long double`로 승격 될 때, 그 값은 변하지 않는다.

`double`이 `float`로 강등되거나 `long double`이 `double`이나 `float`로 강등될 때, 만약 변환되고 있는 값이 표현 가능한 범위를 벗어난다면, 동작은 정의되지 않는다. 만약 변환되고 있는 값이 표현 가능한 범위 안에는 있지만 정확히 표현될 수 없으면, 그 결과는 표현 가능한 가장 가까운 큰 값 또는 가장 가까운 작은 값이 되며, 그 중 어떤 값을 선택할지는 구현에서 정한 방식을 따른다. 

##### 3.2.1.5 일반 산술 변환

산술 타입의 피연산자를 받는 많은 이항 연산자들은 타입 변환을 일으키고 비슷한 방식으로 결과 타입을 구한다. 목적은 공통 타입을 구하는 것이고, 결과 타입도 구한 타입이 된다. 일상적인 산술 변환이라고 이 패턴을 부른다: 먼저, 만약 피연산자 중 `long double` 타입인 것이 있으면, 다른 피연산자도 `long double`로 타입이 변환된다. 그 외에, 만약 피연산자중 `double` 타입인 것이 있으면, 다른 피연산자도 `double`로 타입이 변환된다. 그 외에, 만약 피연산자 중 `float` 타입인 것이 있으면, 다른 피연산자도 `float`로 변환된다. 그 외에, 두 피연산자 모두에서 정수 승격이 이뤄진다. 그리고 나서 다음 규칙들이 적용된다: 만약 피연산자 중 `unsigned long int` 타입인 것이 있으면, 다른 피연산자도 `unsigned long int`로 변환된다. 그 외에, 만약 피연산자 중에 `long int` 타입인 것이 있고, 다른 피연산자가 `unsigned int` 타입인데, 만약 `long int`가 `unsigned int`의 모든 값을 표현할 수 있으면, `unsigned int` 타입의 값이 `long int`로 변환된다; 만약 `long int`가 `unsigned int`의 모든 값을 표현할 수 없으면, 두 피연산자 모두가 `unsigned long int`로 변환된다. 그 외에, 만약 피연산자 중에 `long int`타입인 것이 있으면 다른 피연산자가 `long int`로 변환된다. 그 외에, 만약 피연산자 중에 `unsigned int`타입인 것이 있으면, 다른 피연산자가 `unsigned int`로 변환된다. 그 외의 경우에는, 두 피연산자 모두 `int` 타입이다. 

피연산자들의 값과 수식의 결과값이 타입에서 요구하는 것보다 더 나은 정밀도와 범위를 가지게 표현되어 있을 수도 있지만, 그렇다고 해서 타입이 바뀐 것은 아니다. 

#### 3.2.2 기타 피연산자

##### 3.2.2.1 lvalue와 함수 지정자

lvalue는 수식 중 객체를 지칭하는 것이다(객체 타입, 또는 불완전 타입 중에서 `void`가 아닌 타입의 수식일 수 있다).[^24] 어떤 객체가 특정 타입이라고 했을 때, 그 타입은 그 객체를 지칭하는데 쓰인 lvalue에 의해 정해진다. 수정 가능한 lvalue는 배열 타입이 아니어야 하고, 불완전 타입이 아니어야 하고, `const`로 한정된 타입이 아니어야 하고, 구조체나 공용체의 경우에는 (그 안에 들어있는 모든 구조체와 공용체에 대해서도 재귀적으로) `const`로 한정된 타입의 멤버가 하나도 없어야 한다.

배열 타입이 아닌 lvalue는, `sizeof` 연산자, 단항 `&` 연산자, `++` 연산자, `--` 연산자의 피연산자인 경우나 `.` 연산자 또는 대입 연산자의 왼쪽 피연산자인 경우를 제외하고, 지칭하는 객체에 저장된 값으로 변환된다 (그리고 더이상 lvalue가 아니게 된다). 만약 lvalue가 한정된 타입이라면, 값은 그 타입의 한정되지 않은 버전이고; 그 외의 경우 값의 타입은 lvalue의 타입과 같다. 만약 lvalue가 배열이 아닌 불완전 타입이면, 동작이 정의되지 않는다.

"타입의 배열" 타입인 lvalue는, `sizeof` 연산자나 단항 `&` 연산자의 피연산자인 경우나, 문자 타입의 배열을 초기화하는데 쓰이는 일반 문자열 리터럴인 경우나, `wchar_t`와 호환되는 타입의 배열을 초기화하는데 쓰이는 확장 문자 리터럴인 경우를 제외하고, 배열 객체의 제일 앞의 멤버를 가리키고 타입은 "타입의 포인터"인 수식으로 변환되고, 더이상 lvalue가 아니게 된다. 

함수 지정자는 수식 중 함수를 지칭하는 것이다. `sizeof` 연산자[^25]나 단항 `&` 연산자의 피연산자인 경우를 제외하고, "타입을 반환하는 함수" 타입의 함수 지정자는 "타입을 반환하는 함수의 포인터" 타입으로 변환된다.

**전방 참조**: 주소 및 간접 참조 연산자 ([3.3.3.2](#3332-주소-및-간접-참조-연산자)), 대입 연산자 ([3.3.16](#3316-대입-연산자)), 공통 정의 <stddef.h> ([4.1.5](#415-공통-정의-stddefh)), 초기화 ([3.5.7](#357-초기화)), 후위 증감 연산자 ([3.3.2.4](#3324-후위-증감-연산자)), 전위 증감 연산자 ([3.3.3.1](#3331-전위-증감-연산자)), sizeof 연산자 ([3.3.3.4](#3334-sizeof-연산자)), 구조체 및 공용체 멤버 ([3.3.2.3](#3323-구조체-및-공용체-멤버)).

##### 3.2.2.2 void

`void` 식 (`void` 타입인 식)의 (존재하지 않는) 값은 어떤 방식으로든 쓰이지 말아야 하며, 자동 또는 명시적 변환 (`void`로를 제외하고)는 해당 식에 적용하지 말아야 한다. 만약 `void` 식이 필요한 자리에 다른 타입의 수식이 나타나면, 그 값이나 지정자는 버려진다. (`void 식은 부수 효과를 얻기 위해 평가된다.)

##### 3.2.2.3 포인터

`void` 포인터는 어떤 불완전 타입 또는 객체 타입의 포인터로든 변환될 수 있고, 어떤 불완전 타입 또는 객체 타입의 포인터든지 `void` 포인터로 변환될 수 있다. 불완전 타입 또는 객체 타입의 포인터는 `void` 포인터로 변환된 후에 다시 원래 포인터로 변환될 수 있고; 그 결과값은 원래 포인터와 같아야 한다.

q로 한정되지 않은 포인터는 q로 한정된 포인터로 변환될 수 있고; 원래 포인터에 저장된 값과 변환된 포인터에 저장된 값을 비교하면 같아야 한다. 

정수 상수식의 값이 `0`인 것, 또는 그런 수식을 `void *`로 변환한 것은, null 포인터 상수라고 불린다. null 포인터 상수가 어떤 포인터에 대입되거나 어떤 포인터와 같은지 비교될 때, 이 상수의 타입이 해당 포인터의 타입으로 변환된다. 그렇게 타입이 변한된 포인터를 null 포인터라고 부르며, 객체나 함수를 가리키는 어떤 포인터와 비교해도 다름이 보장된다. 

두 null 포인터들은, 다른 타입 변환 과정을 거쳤더라도, 비교했을 때 항상 같아야 한다. 

**전방 참조**: 타입 변환 연산자 ([3.3.4](#334-타입-변환-연산자)), 등가 연산자 ([3.3.9](#339-등가-연산자)), 단순 대입 ([3.3.16.1](#33161-단순-대입)).

### 3.3 수식

#### 3.3.1 기본 수식

#### 3.3.2 후위 연산자

##### 3.3.2.1 배열 첨자

##### 3.3.2.2 함수 호출

##### 3.3.2.3 구조체 및 공용체 멤버

##### 3.3.2.4 후위 증감 연산자

#### 3.3.3 단항 연산자

##### 3.3.3.1 전위 증감 연산자

##### 3.3.3.2 주소 및 간접 참조 연산자

##### 3.3.3.3 단항 산술 연산자

##### 3.3.3.4 sizeof 연산자

#### 3.3.4 타입 변환 연산자

#### 3.3.5 곱셈 연산자

#### 3.3.6 덧셈 연산자

#### 3.3.7 비트 시프트 연산자

#### 3.3.8 관계 연산자

#### 3.3.9 등가 연산자

#### 3.3.10 비트 AND 연산자

#### 3.3.11 비트 배타적 OR 연산자

#### 3.3.12 비트 포과적 OR 연산자

#### 3.3.13 논리 AND 연산자

#### 3.3.14 논리 OR 연산자

#### 3.3.15 조건 연산자

#### 3.3.16 대입 연산자

##### 3.3.16.1 단순 대입

##### 3.3.16.2 복합 대입

#### 3.3.17 쉼표 연산자

### 3.4 상수 수식

### 3.5 선언

#### 3.5.1 저장 종류 지정자

#### 3.5.2 타입 지정자

##### 3.5.2.1 구조체 및 공용체 지정자

##### 3.5.2.2 열거체 지정자

##### 3.5.2.3 태그(

#### 3.5.3 타입 한정자

#### 3.5.4 선언자

##### 3.5.4.1 포인터 선언자

##### 3.5.4.2 배열 선언자

##### 3.5.4.3 함수 선언자(프로토타입 포함)

#### 3.5.5 타입 이름

#### 3.5.6 타입 정의

#### 3.5.7 초기화

### 3.6 문장

#### 3.6.1 라벨이 붙은 문장

#### 3.6.2 복합문 또는 블록

#### 3.6.3 수식문과 null 문

#### 3.6.4 선택문

##### 3.6.4.1 if 문

##### 3.6.4.2 switch 문

#### 3.6.5 반복문

##### 3.6.5.1 while 문

##### 3.6.5.2 do 문

##### 3.6.5.3 for 문

#### 3.6.6 점프문

##### 3.6.6.1 goto 문

##### 3.6.6.2 continue 문

##### 3.6.6.3 break 문

##### 3.6.6.4 return 문

### 3.7 외부 정의

#### 3.7.1 함수 정의

#### 3.7.2 외부 객체 정의

### 3.8 전처리 지시문

#### 3.8.1 조건부 포함

#### 3.8.2 소스 파일 포함

#### 3.8.3 매크로 치환

##### 3.8.3.1 인자 치환

##### 3.8.3.2 # 연산자

##### 3.8.3.3 ## 연산자

##### 3.8.3.4 재스캔 및 추가 치환

##### 3.8.3.5 매크로 정의의 범위

#### 3.8.4 줄 제어

#### 3.8.5 에러 지시문

#### 3.8.6 pragma 지시문

#### 3.8.7 null 지시문

#### 3.8.8 미리 정의된 매크로 이름

### 3.9 향후 언어 방향

#### 3.9.1 외부 이름

#### 3.9.2 문자 이스케이프 시퀀스

#### 3.9.3 저장 클래스 지정자

#### 3.9.4 함수 선언자

#### 3.9.5 함수 정의

## 4. 라이브러리

### 4.1 개요

#### 4.1.1 용어의 정의

#### 4.1.2 표준 헤더

#### 4.1.3 에러 <errno.h>

#### 4.1.4 한계 <float.h> 및 <limits.h>

#### 4.1.5 공통 정의 <stddef.h>

#### 4.1.6 라이브러리 함수 사용

### 4.2 진단 <assert.h>

#### 4.2.1 프로그램 진단

##### 4.2.1.1 assert 매크로

### 4.3 문자 처리 <ctype.h>

#### 4.3.1 문자 검사 함수

##### 4.3.1.1 isalnum 함수

##### 4.3.1.2 isalpha 함수

##### 4.3.1.3 iscntrl 함수

##### 4.3.1.4 isdigit 함수

##### 4.3.1.5 isgraph 함수

##### 4.3.1.6 islower 함수

##### 4.3.1.7 isprint 함수

##### 4.3.1.8 ispunct 함수

##### 4.3.1.9 isspace 함수

##### 4.3.1.10 isupper 함수

##### 4.3.1.11 isxdigit 함수

#### 4.3.2 문자 대소문자 매핑 함수

##### 4.3.2.1 tolower 함수

##### 4.3.2.2 toupper 함수

### 4.4 국제화 <locale.h>

#### 4.4.1 locale 제어

##### 4.4.1.1 setlocale 함수

#### 4.4.2 숫자 서식 관례 조회

##### 4.4.2.1 localeconv 함수

### 4.5 수학 <math.h>

#### 4.5.1 에러 조건 처리

#### 4.5.2 삼각 함수

##### 4.5.2.1 acos 함수

##### 4.5.2.2 asin 함수

##### 4.5.2.3 atan 함수

##### 4.5.2.4 atan2 함수

##### 4.5.2.5 cos 함수

##### 4.5.2.6 sin 함수

##### 4.5.2.7 tan 함수

#### 4.5.3 쌍곡선 함수

##### 4.5.3.1 cosh 함수

##### 4.5.3.2 sinh 함수

##### 4.5.3.3 tanh 함수

#### 4.5.4 지수 및 로그 함수

##### 4.5.4.1 exp 함수

##### 4.5.4.2 frexp 함수

##### 4.5.4.3 ldexp 함수

##### 4.5.4.4 log 함수

##### 4.5.4.5 log10 함수

##### 4.5.4.6 modf 함수

#### 4.5.5 거듭제곱 함수

##### 4.5.5.1 pow 함수

##### 4.5.5.2 sqrt 함수

#### 4.5.6 근접 정수, 절댓값, 나머지 함수

##### 4.5.6.1 ceil 함수

##### 4.5.6.2 fabs 함수

##### 4.5.6.3 floor 함수

##### 4.5.6.4 fmod 함수

### 4.6 비지역 점프 <setjmp.h>

#### 4.6.1 호출 환경 저장

##### 4.6.1.1 setjmp 매크로

#### 4.6.2 호출 환경 복원

##### 4.6.2.1 longjmp 함수

### 4.7 신호 처리 <signal.h>

#### 4.7.1 신호 처리 지정

##### 4.7.1.1 signal 함수

#### 4.7.2 신호 보내기

##### 4.7.2.1 raise 함수

### 4.8 가변 인자(variable arguments) <stdarg.h>

#### 4.8.1 가변 인자 리스트 접근 매크로

##### 4.8.1.1 va_start 매크로

##### 4.8.1.2 va_arg 매크로

##### 4.8.1.3 va_end 매크로

### 4.9 입출력 <stdio.h>

#### 4.9.1 개요

#### 4.9.2 스트림

#### 4.9.3 파일

#### 4.9.4 파일에 대한 연산

##### 4.9.4.1 remove 함수

##### 4.9.4.2 rename 함수

##### 4.9.4.3 tmpfile 함수

##### 4.9.4.4 tmpnam 함수

#### 4.9.5 파일 접근 함수

##### 4.9.5.1 fclose 함수

##### 4.9.5.2 fflush 함수

##### 4.9.5.3 fopen 함수

##### 4.9.5.4 freopen 함수

##### 4.9.5.5 setbuf 함수

##### 4.9.5.6 setvbuf 함수

#### 4.9.6 형식 지정 입출력 함수

##### 4.9.6.1 fprintf 함수

##### 4.9.6.2 fscanf 함수

##### 4.9.6.3 printf 함수

##### 4.9.6.4 scanf 함수

##### 4.9.6.5 sprintf 함수

##### 4.9.6.6 sscanf 함수

##### 4.9.6.7 vfprintf 함수

##### 4.9.6.8 vprintf 함수

##### 4.9.6.9 vsprintf 함수

#### 4.9.7 문자 입출력 함수

##### 4.9.7.1 fgetc 함수

##### 4.9.7.2 fgets 함수

##### 4.9.7.3 fputc 함수

##### 4.9.7.4 fputs 함수

##### 4.9.7.5 getc 함수

##### 4.9.7.6 getchar 함수

##### 4.9.7.7 gets 함수

##### 4.9.7.8 putc 함수

##### 4.9.7.9 putchar 함수

##### 4.9.7.10 puts 함수

##### 4.9.7.11 ungetc 함수

#### 4.9.8 직접 입출력 함수

##### 4.9.8.1 fread 함수

##### 4.9.8.2 fwrite 함수

#### 4.9.9 파일 위치 지정 함수

##### 4.9.9.1 fgetpos 함수

##### 4.9.9.2 fseek 함수

##### 4.9.9.3 fsetpos 함수

##### 4.9.9.4 ftell 함수

##### 4.9.9.5 rewind 함수

#### 4.9.10 에러 처리 함수

##### 4.9.10.1 clearerr 함수

##### 4.9.10.2 feof 함수

##### 4.9.10.3 ferror 함수

##### 4.9.10.4 perror 함수

### 4.10 일반 유틸리티 <stdlib.h>

#### 4.10.1 문자열 변환 함수

##### 4.10.1.1 atof 함수

##### 4.10.1.2 atoi 함수

##### 4.10.1.3 atol 함수

##### 4.10.1.4 strtod 함수

##### 4.10.1.5 strtol 함수

##### 4.10.1.6 strtoul 함수

#### 4.10.2 의사 난수 수열 생성 함수

##### 4.10.2.1 rand 함수

##### 4.10.2.2 srand 함수

#### 4.10.3 메모리 관리 함수

##### 4.10.3.1 calloc 함수

##### 4.10.3.2 free 함수

##### 4.10.3.3 malloc 함수

##### 4.10.3.4 realloc 함수

#### 4.10.4 환경과의 통신

##### 4.10.4.1 abort 함수

##### 4.10.4.2 atexit 함수

##### 4.10.4.3 exit 함수

##### 4.10.4.4 getenv 함수

##### 4.10.4.5 system 함수

#### 4.10.5 검색 및 정렬 유틸리티

##### 4.10.5.1 bsearch 함수

##### 4.10.5.2 qsort 함수

#### 4.10.6 정수 산술 함수

##### 4.10.6.1 abs 함수

##### 4.10.6.2 div 함수

##### 4.10.6.3 labs 함수

##### 4.10.6.4 ldiv 함수

#### 4.10.7 멀티 바이트 문자 함수

##### 4.10.7.1 mblen 함수

##### 4.10.7.2 mbtowc 함수

##### 4.10.7.3 wctomb 함수

#### 4.10.8 멀티 바이트 문자열 함수

##### 4.10.8.1 mbstowcs 함수

##### 4.10.8.2 wcstombs 함수

### 4.11 문자열 처리 <string.h>

#### 4.11.1 문자열 함수 규약

#### 4.11.2 복사 함수

##### 4.11.2.1 memcpy 함수

##### 4.11.2.2 memmove 함수

##### 4.11.2.3 strcpy 함수

##### 4.11.2.4 strncpy 함수

#### 4.11.3 연결 함수

##### 4.11.3.1 strcat 함수

##### 4.11.3.2 strncat 함수

#### 4.11.4 비교 함수

##### 4.11.4.1 memcmp 함수

##### 4.11.4.2 strcmp 함수

##### 4.11.4.3 strcoll 함수

##### 4.11.4.4 strncmp 함수

##### 4.11.4.5 strxfrm 함수

#### 4.11.5 검색 함수

##### 4.11.5.1 memchr 함수

##### 4.11.5.2 strchr 함수

##### 4.11.5.3 strcspn 함수

##### 4.11.5.4 strpbrk 함수

##### 4.11.5.5 strrchr 함수

##### 4.11.5.6 strspn 함수

##### 4.11.5.7 strstr 함수

##### 4.11.5.8 strtok 함수

#### 4.11.6 기타 함수

##### 4.11.6.1 memset 함수

##### 4.11.6.2 strerror 함수

##### 4.11.6.3 strlen 함수

### 4.12 날짜와 시간 <time.h>

#### 4.12.1 시간의 구성 요소

#### 4.12.2 시간 조작 함수

##### 4.12.2.1 clock 함수

##### 4.12.2.2 difftime 함수

##### 4.12.2.3 mktime 함수

##### 4.12.2.4 time 함수

#### 4.12.3 시간 변환 함수

##### 4.12.3.1 asctime 함수

##### 4.12.3.2 ctime 함수

##### 4.12.3.3 gmtime 함수

##### 4.12.3.4 localtime 함수

##### 4.12.3.5 strftime 함수

### 4.13 향후 라이브러리 방향

#### 4.13.1 에러 <errno.h>

#### 4.13.2 문자 처리 <ctype.h>

#### 4.13.3 지역화 <locale.h>

#### 4.13.4 수학 <math.h>

#### 4.13.5 신호 처리 <signal.h>

#### 4.13.6 입출력 <stdio.h>

#### 4.13.7 일반 유틸리티 <stdlib.h>

#### 4.13.8 문자열 처리 <string.h>

## A. 부록

### A.1 언어 구문 요약

#### A.1.1 어휘 문법

##### A.1.1.1 토큰

##### A.1.1.2 키워드

##### A.1.1.3 식별자

##### A.1.1.4 상수

##### A.1.1.5 문자열 리터럴

##### A.1.1.6 연산자

##### A.1.1.7 구두점

##### A.1.1.8 헤더 이름

##### A.1.1.9 전처리 숫자

#### A.1.2 구문 구조 문법

##### A.1.2.1 수식

##### A.1.2.2 선언

##### A.1.2.3 문장

##### A.1.2.4 외부 정의

#### A.1.3 전처리 지시문

### A.2 시퀀스 포인트

### A.3 라이브러리 요약

#### A.3.1 에러 <errno.h>

#### A.3.2 공통 정의 <stddef.h>

#### A.3.3 진단 <assert.h>

#### A.3.4 문자 처리 <ctype.h>

#### A.3.5 국제화 <locale.h>

#### A.3.6 수학 <math.h>

#### A.3.7 비지역 점프 <setjmp.h>

#### A.3.8 신호 처리 <signal.h>

#### A.3.9 가변 인자 <stdarg.h>

#### A.3.10 입출력 <stdio.h>

#### A.3.11 일반 유틸리티 <stdlib.h>

#### A.3.12 문자열 처리 <string.h>

#### A.3.13 날짜와 시간 <time.h>

### A.4 구현 한계

### A.5 공통 경고

### A.6 이식성 문제

#### A.6.1 미지정 동작

#### A.6.2 정의되지 않은 동작

#### A.6.3 구현 정의 동작

##### A.6.3.1 환경

##### A.6.3.2 식별자

##### A.6.3.3 문자

##### A.6.3.4 정수

##### A.6.3.5 실수

##### A.6.3.6 배열과 포인터

##### A.6.3.7 레지스터

##### A.6.3.8 구조체, 공용체, 열거 타입, 비트 필드

##### A.6.3.9 한정자

##### A.6.3.10 선언자

##### A.6.3.11 문장

##### A.6.3.12 전처리 지시문

##### A.6.3.13 라이브러리 함수

#### A.6.4 locale 특화 동작

#### A.6.5 일반적인 확장

##### A.6.5.1 환경 인자

##### A.6.5.2 특수 식별자

##### A.6.5.3 식별자의 길이와 대/소문자

##### A.6.5.4 식별자의 유효 범위

##### A.6.5.5 쓰기 가능한 문자열 리터럴

##### A.6.5.6 기타 산술 타입

##### A.6.5.7 함수 포인터 타입 변환

##### A.6.5.8 int가 아닌 비트 필드 타입

##### A.6.5.9 fortran 키워드

##### A.6.5.10 asm 키워드

##### A.6.5.11 다중 외부 정의

##### A.6.5.12 빈 매크로 인자

##### A.6.5.13 미리 정의된 매크로 이름

##### A.6.5.14 신호 처리기에 대한 추가 인자

##### A.6.5.15 추가 스트림 유형 및 파일 열기 모드

##### A.6.5.16 정의된 파일 위치 표시자

### A.7 색인

[^1]: 이 표준은 다양한 데이터 처리 시스템들 사이에서 C 프로그램의 이식성을 증진하도록 설계되었다. 이 표준은 구현자와 숙련된 프로그래머가 사용하는 것을 의도하며, 입문서가 아니다. 또한 이 표준에는, 이를 작성한 기술위원회의 여러 결정 사항을 설명하는 근거서 문서가 함께 제공된다.

[^2]: 엄격하게 적합한 프로그램은 적합 구현들 사이에서 최대한 이식 가능한 것이 의도되었다. 적합한 프로그램은 적합 구현에서 제공하는 이식 불가능한 기능을 쓸 수도 있다.

[^3]: 보통 실제로 처리될 때는 많은 단계가 통합되어 처리되지만, 구현은 각 단계들이 별개로 처리되는 것과 같이 동작해야 한다.

[^4]: 3.1에서 설명된 바와 같이, 소스 파일의 문자들을 전처리 토큰으로 나누는 과정은 문맥 의존적이다. 한 예로 `#include` 전처리 지시문 내부에서의 `<` 처리 방식이 있다.

[^5]: 삼중문자 시퀀스는 7비트 ASCII 코드 세트의 부분집합인 "ISO 646-1983" 불변 코드 세트에 정의되지 않은 문자를 입력할 수 있게 해준다.

[^6]: 구현체는 가능한 한 고정된 변환 한계를 두지 말아야 한다.

[^7]: [3.1.2.5](#3125-타입) 참조.

[^8]: 이 모델은 부호-절댓값 방식 이외의 부동 소수점 표현 방식은 배제한다.

[^9]: 해당 표준의 부동 소수점 모델은 0부터 시작하여 거듭제곱을 합산하므로, 지수 한계값은 여기에 표시된 값보다 1만큼 작다.

[^10]: "향후 언어 방향" ([3.9.1](#391-외부-이름))을 보라.

[^11]: 세 가지 종류가 가능하지만, 태그를 위한 이름 공간은 단 하나만 존재한다.

[^12]: volatile 객체의 경우, 마지막 저장 동작이 프로그램 코드 내에 명시적으로 나타나지 않을 수 있다.

[^13]: 이진 숫자 0과 1을 사용하는 정수의 위치 표기법으로, 이 표기법에서 연속적인 비트가 나타내는 값들은 서로 더해지고, 1부터 시작하고, 2의 정수 거듭제곱을 차례로 곱해서 구해진다. 가장 높은 위치의 비트는 예외일 수 있다.

[^14]: 묶음 타입에는 공용체 타입이 포함되지 않는데, 그 이유는 공용체 타입의 객체가 한 번에 하나의 멤버만 포함할 수 있기 때문이다.

[^15]: 한정된 타입에는 세 가지의 서로 다른 조합이 존재한다.

[^16]: 두 타입이 호환되기 위해서 반드시 동일할 필요는 없다.

[^17]: 이 문자들의 의미는 [2.2.2](#222-문자-표시-의미론)에서 논의되었다.

[^18]: "향후 언어 방향" ([3.9.2](#392-문자-이스케이프-시퀀스))을 참조하라.

[^19]: 문자열 리터럴은 문자열이 아닐 수도 있는데 ([4.1.1](#411-용어의-정의)를 보라), 그 이유는 null 문자가 \0 이스케이프 시퀀스를 통해 중간에 들어있을 수 있기 때문이다.

[^20]: 따라서 이스케이프 시퀀스와 유사해 보이는 문자 나열은 정의되지 않은 동작을 발생시킨다.

[^21]: 따라서 주석은 중첩되지 않는다.

[^22]: 2의 보수 표현법에서, 만약 부호 없는 정수의 크기가 더 크다면, 자리수가 큰 비트들에 부호 비트를 복사해서 채우는 것 외에는 실제 비트 패턴에 변화가 없다.

[^23]: 정수 계열 타입을 `unsigned` 타입으로 변환할 때 실행되는 나머지 연산은, 실수 타입을 `unsigned` 타입으로 변환할 때는 실행될 필요가 없다. 그러므로 이식 가능한 값의 범위는 [0, U type_MAX + 1)이다. 

[^24]: "lvalue"라는 이름의 유래는 대입식 `E1 = E2`인데, 여기서 왼쪽 피연산자 `E1`은 반드시 (변경 가능한) lvalue여야 한다. 어쩌면 이것이 객체의 "위치 값"을 나타낸다고 하는 것이 나을 수도 있다. 본 표준에서 종종 "rvalue"라고 부르는 것은 "수식의 값"으로 설명된다. lvalue의 자명한 예는 객체의 식별자다. 또 다른 예로, 만약 `E`라는 단항식이 객체의 포인터라면, `*E`는 lvalue로, `E`가 가리키는 객체를 지정한다. 

[^25]: 이 변환이 발생하지 않기 때문에, `sizeof` 연산자의 피연산자는 함수 지정자로 남아있으며, [3.3.3.4](#3334-sizeof-연산자)의 제약 사항을 위반한다. 

